# State Management
## 개요
- 상태 관리 : Vue 컴포넌트는 이미 반응형 상태 관리중.</br>=> 상태 === 데이터
### 컴포넌트 구조의 단순화
- 상태(state) : 앱 구동에 필요한 기본 데이터
- 뷰(view) : 상태를 선언적으로 매핑하여 시각화
- 기능(actions) : 뷰에서 사용자 입력에 대해 반응적으로 상태를 변경할 수 있게 정의된 동작</br>
=> "단방향 데이터 흐름"의 간단한 표현
### 상태 관리의 단순성이 무너질 때
- 여러 컴포넌트가 상태 공유할 때
  - 여러 뷰가 동일한 상태에 종속
    - 공유 상태를 공통 조상 컴포넌트로 끌어올려 props로 전달
    - 계층 구조가 깊어질 경우 비효율, 관리 어려움
  - 서로 다른 뷰의 기능이 동일한 상태 변경
    - 발신(emit)된 이벤트를 통해 상태의 여러 복사본을 변경 및 동기화
    - 관리의 패턴 깨지기 쉬움, 유지 관리 어려운 코드
### 상태 관리 해결책
- 각 컴포넌트의 공유 상태 추출, 전역에서 참조 가능한 저장소에서 관리
- 컴포넌트 트리는 하나의 큰 view 가 되고 모든 컴포넌트는 트리 계층 구조에 관계없이 상태에 접근하거나 기능 사용 가능 <br>
=> Vue의 공식 상태 관리 라이브러리 === Pinia</br>

+++그렇다고 전에 배운 props/emit 패턴이 쓸모없어지는 건 아님. 작은 앱이나 단순한 상태 공유에는 여전히 유용.
- 상위 컴포넌트가 pinia 에서 데이터 받아와서 하위에 props 로 전달 가능
- emit 대신 actions로 상태 변경 요청해서 pinia가 상태 변경, 변경된 걸 상위 컴포넌트가 반영
## State Management Library (Pinia)
- Pinia : Vue의 공식 상태 관리 라이브러리
  - vite 프로젝트 빌드 시 pinia 라이브러리 추가 가능</br> 
  -> stores 폴더 신규 생성
  - vue2때는 vuex 사용했음
  - 뭔가 길게 설명이 있었는데 js문법 쓰면 된다는 얘기인듯
- 프로젝트 pinia 집어넣은 채로 만들면 store 폴더에 counter.js 같은 파일이 생김
  - defineStore() 함수로 스토어 정의되어있음
  - export const useCounterStore = defineStore('counter', { 화살표함수(ref 변수, 그 변수에 계산되는 속성, 받는 행동), setup() 쓰듯이 객체 반환함})
  - 외울 필요는 없는데 공식문서 보면 보통 이런 형태로 나옴
  - store에 정의하는 모든 변수는 공개적이어야 한다!
    - 반환 안해도 오류는 안나지만 공개적으로 쓸것만 정의해서 반환하는게 좋음.
    - 모든 컴포넌트에서 접근 가능한 곳. 쓸데없는거 정의해서 접근가능하게 만들지 말자
  - 내보낼 필요 없는 건 useCounterStore 외부에서 만들어서 사용(같은파일, 그냥 바깥쪽이라는뜻)
  - 저장소의 데이터 바꾸지 말고 actions 통해서 바꾸기
  - 엄격하게 써보고 싶다면 optionsAPI 사용해보기
### Pinia 구성 요소
- Store : 중앙 저장소
  - 모든 컴포넌트 공유하는 상태, 기능 작성됨
  - defineStore()로 생성, 반환값 이름은 use, store 사용하는 것 권장
  - defineStore()의 첫 번째 인자는 애플리케이션 전체에 걸쳐 사용하는 store 고유 ID
- 상태(state) : 반응형 상태(데이터) 저장
  - ref() === state
- 게터(getters) : 상태 기반 계산된 속성
  - computed() === getters
- 기능(actions) : 상태 변경 메서드
- 플러그인(plugins) : 스토어 기능 확장
  - 상태 관리 필요 추가 기능 확장
### Pinia 구성 요소 활용


## Local Storage
- 브라우저 내에 key-value 쌍으로 데이터 저장하는 웹 스토리지 객체
### 특징
- 페이지 새로고침하고 브라우저 다시 실행해도 데이터 유지 (유튜브에서 음소거 상태 기억하는 것처럼)
- 쿠키와 다르게 네트워크 요쳥 시 서버로 전송되지 않음
- 여러 탭, 창간 데이터 공유
- 개발자 도구 application 탭에서 확인 가능
- 크롬 파일에 저장됨
### 사용 목적
- 웹 애플리케이션에서 사용자 설정, 세션 정보, 캐시 데이터 등을 클라이언트 측에 저장, 웹사이트의 성능 향상 및 사용자 경험 개선
### pinia-plugin-persistedstate
- pinia의 플러그인 중 하나
- 웹 애플리케이션 상태를 브라우저의 local storage나 session storage에 영구적으로 저장, 복원하는 기능 제공
### 설치
- 설치: npm install pinia-plugin-persistedstate
- main.js에서 pinia 플러그인 추가
- defineStore에서 persist 옵션 추가
- 공식문서에 있는거 복붙해도된

## Routing
### 개요
- Routing : 네트워크에서 경로 선택하는 프로세스
- 웹 애플리케이션에서 다른 페이지 간의 전환과 경로 관리 기술
- ssr에서 라우팅은 서버측에서 수행
- CSR에서 라우팅은 클라이언트측에서 수행
- 클라이언트 측 js가 새 데이터 동적으로 가져와 전체 페이지 다시 로드되지 않음
### SPA에서 라우팅이 없다면
- 브라우저의 뒤로 가기 기능 사용 불가
- url을 통한 페이지 변화 감지 불가
- 페이지가 무엇을 렌더링 중인지 상태 알 수 없음
  - url이 바뀌지 않으므로 새로고침 시 처음 페이지로 되돌아감
  - 링크를 공유할 시 첫 페이지만 공유 가능
### Vue Router
- Vue.js 공식 라우팅 라이브러리
- 프로젝트 생성 시 router 추가 가능
- 링크 클릭하면 페이지 전환, url 변경
- 기본 페이지 만들면 router 폴더, views 폴더 생성됨
- lazy loading 주로 사용
  - lazy loading : 필요할 때만 해당 컴포넌트 로드
- 라우트라고 부르지만 루트라고 생각하면 될듯. 
  - routes라는 객체에 경로들을 적어 정의해둔다
  - 이걸 RouterLink로 접속, RouterView로 보여줌
- routerView를 동시에 띄우기?
  - router를 잘못 사용하는 듯
  - 1 view로 보여줄 건 1페이지
  - 뷰 중첩은 상속관계 정도
  - 프로필 카드의 세부 탭 같은것에 사용
  - 한 경로에 두개의 라우터는 있을 수 없다. 서브라우터는 가능
- 상대경로 vs 절대경로
  - 절대경로: 보통 외부 url에 사용
  - 상대경로: 내부 링크 대부분에서 사용
- 링크 이름 바꿀거면 index.js랑 app.vue 둘다 바꿔줘야함
### named Route
- 라우트 이름 객체로 저장 가능
- v-bind로 to props 객체로 전달
- `<RouterLink :to="{name:'about'}">About</RouterLink>`
- 하드코딩url 사용 안해도 됨
- url입력시 오타 방지
### 동적 라우트 매칭(Dynamic Route Matching)
- url의 일부를 변수로 사용, 경로 동적 매칭
- 모든 사용자의 id 활용해 프로필 페이지 만들 때 유용
- 주어진 패턴 경로를 동일 컴포넌트에 매핑시 사용
- 매개변수 콜론(`:`)으로 표시

### 프로그래밍 방식 네비게이션
- `<RouterLink>` 대신 자바스크립트 코드로 라우트 변경
- `this.$router.push()` 또는 `this.$router.replace()` 사용
  - push : 다른 위치로 이동
  - replace : 현재 위치 변경
## 참고
- 참고 페이지 많이 읽어볼 것(94p)
- vue 이게 끝 아니고 마지막쯤에 더 할거니 까먹지말기