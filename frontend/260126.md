# Component State Flow
## Passing Props
- 동일 데이터 다른 컴포넌트
    - 컴포넌트가 여러 개라면 개별적으로 동일한 데이터를 관리해야 하는가?<br>
    => 사진 변경 시마다 모든 컴포넌트에 대해 변경 요청 필요 <br>
    => 공통된 부모 컴포넌트에서 관리 (최상단에서 받아와서 하위 컴포넌트로 내려주기)
- 프로필 이미지 같은 건 서버에서 받아와서 사용하는데 각 컴포넌트마다 동일한 데이터를 관리하는 건 비효율적
- 부모 : 자식에게 데이터 전달(pass props), <br>
  자식 : 자신에게 일어난 일 부모에게 알림(emit event)<br>
  (프로필 이미지 변경 요청 )
### Props
- 부모 컴포넌트로부터 자식 컴포넌트로 데이터 전달 시 사용되는 속성
- 특징:
  - 단방향 바인딩(부모 -> 자식) : 부모 속성 업데이트-> 자식 전달 / 반대는 불가 (내려주기만 가능)
  - 자식 컴포넌트 내부에서 props 변경 불가
  - 부모 컴포넌트 업데이트 될 때마다 자식 컴포넌트에 전달되는 모든 props 업데이트<br>
=>부모 컴포넌트에서만 변경, 자식 컴포넌트는 자동 갱신
- one-way data flow
  - 모든 props는 자식 속성과 부모 속성 사이에 **하향식 단방향 바인딩**을 형성
- 왜 단방향인가?
  - 데이터가 어디서 어떻게 변경되고 있는지 알기 쉬움
  - 말단 컴포넌트가 변동되었을 때 옆의 컴포넌트에 변동되었다는 걸 알리기 어려움 -> 부모로 올려서 부모가 한번에 관리
  - 뭔가 에러가 났을 때 어디컴포넌트인지 덜 찾아도 됨
  - 하위 컴포넌트가 실수로 상위 컴포넌트의 상태를 변경하여 앱에서이 데이터 흐름을 이해하기 어렵게 하는 것 방지<br>
  => 데이터 흐름 일관성, 단순화
- eventBus라는 거 있는데 노선 없는 버스 같은 것. prop, emit 안해도 되는데 유지보수는 개나줬으니 쓰지말기
### props 선언
- 실습(p20~)
- vue 프로젝트 생성, 마지막 default 프로젝트 no 선택해서 빈 프로젝트로 생성
- parent 컴포넌트 => html 요소로 사용
- parentchild 컴포넌트로 속성 보내기 가능
- 부모 컴포넌트 parent에서 자식 으로 속성 보냄
- 자식 컴포넌트 child에서 defineProps로 props 생성해서 받음
- ** 타입 지정은 설명만되고 다른 타입 들어가도 오류 안남
- props는 읽기 전용
- props 만들고 변수에 저장, 변수로 읽기 가능. 읽기만 가능! (script에서)
- html에서는 prop받아온 데이터 그냥 출력 가능
- 결과 화면 캡쳐해서 영역 그려보기
- 과제 저장하는 곳에 실습한 파일 올려둠
- parentitem에서 뭔가 잘못됐는데 강의 다시볼
### props 세부사항
-  Props Name Casing

- Static Props 와 Dynamic Props

### Props 활용

## Component Events
### Emit
- 자식 컴포넌트가 이벤트를 발생시켜 부모 컴포넌트로 전달하는 역할의 메서드
- $emit(event, ...args)
  - event: 발생시킬 이벤트 이름
  - args: 이벤트 핸들러로 전달할 추가 인자
### 이벤트 발신 및 수신
- $emit사용하여 템플릿 표현식에서 직접 사용자 정의 이벤트 발신
- 그럼 부모는 v-on 사용하여 수신 가능
- ++그럼 부모에서 이벤트를 다갖고있는거?
### eimt 이벤트 선언
- defineEmits() 함수 사용
- props 와 비슷하게 작성하는 인자 타입에 따라 선언 방식 나뉨(배열, 객체)
- defineEmits()는 $emit 대신 사용할 수 있는 동등한 함수 반환(script에서는 $emit접근 불가)
### emit 이벤트 활용
- 이벤트 넘기는건 js랑 똑같음

## Computed Properties
- 계산된 속성을 정의하는 함수
- sample code extra 폴더에서 진행
- 미리 계산된 속성 사용 (캐싱 사용) -> 표현식 단순하게, 불필요한 반복 연산 줄임

### Computed
### Computed vs Methods
- coputed는 여러번 갖다써도 한번만 계산
  - 의존된 반응형 데이터 자동추적 -> 반응형 사용가능
  - 변화할때마다 계산
  - 이해하려면 getter, setter 개념 알아야함
- 메서드 방식은 메서드 호출해야 정보가 나옴 
  - 메서드 호출 시마다 함수 재실행(계산)
  - 함수 실행결과를 변수에 집어넣고 쓸수는 있음. 대신 반응형이안됨

- computed
  - 의존하는 데이터에 따라 결과 변경되는 계산된 속성 필요시
  - 동일 의존성 가진 여러 곳에서 사용시 계산 결과 캐싱 -> 중복 계산 방지
  - 의존 데이터 변경시 업데이트

- method
  - 단순히 특정 동작 수행하는 함수 정의 필요시
  - 데이터에 의존 여부 관계없이 항상 동일 결과 반환 함수 필요시
  - 호출 시 실행
- 사용 목적과 상황에 맞게 적절히 조합

## Watchers
### Watch
- **하나 이상**의 반응형 데이터 감시, 변경시 콜백 함수 호출
- watch(source, (newValue, oldValue) => { ... })
  - source: 감시할 반응형 데이터(함수, ref, computed 등)
  - 두번째 괄호는 콜백함수
  - newValue: 변경된 새 값
  - oldValue: 이전 값
- 여러개 감시하고싶으면 배열로 묶기
### computed vs watch(중요)
- (p94)
- computed
  - 하나만 계산, 감지
  - 계산한 값 캐싱 ->재사용
- watch
  - 여러개 감지 가능
  - 데이터 변화에 따른 작업 수행

## 추가
### Lifecycle Hooks
- vue 인스턴스 생애주기 동안 특정 시점에 실행되는 함수
- onMounted, onUpdated, onUnmounted 등
- 생기는순간, 부착되는순간 , 업데이트되는순간, 제거되는순간 실행됨
- onMounted 에다가 뭐 집어넣고 실행가능
### virtual DOM
- 오늘은 그런게 있다 정도만 알고 읽어보기만(p106)