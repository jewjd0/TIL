# Introduction of Vue
## Frontend Development
- 웹사이트와 웹 애플리케이션의 사용자 인터페이스(UI)와 사용자 경험(UX)을 만들고 디자인하는 것<br>
=> HTML, CSS, JavaScript등을 활용하여 사용자가 직접 상호작용하는 부분 개발
### Client-side frameworks
- 클라이언트 측에서 UI와 상호작용을 개발하기 위해 사용되는 JavaScript 기반 프레임워크
- ex. Vue, React, .Angular ... (리액트는 라이브러리이긴 한데 구분이 갈수록 애매해짐)
- Client-side frameworks가 필요한 이유
  - 웹에서 하는 일이 많아짐.<br>
  단순히 뭔가를 읽는 곳 -> 뭔가 하는 곳
  - 사용자는 웹에서 문서만 읽는 게 아님. 음악 스트리밍, 영화 보기, 지구 반대편 사람들과 텍스트 및 영상 채팅을 통해 즉시 통식
  - 현대적이고 복잡한 대화형 웹 사이트: 웹 애플리케이션
  - js 기반의 client-side frameworks가 등장하면서 매우 동적인 대화형 애플리케이션을 훨씬 더 쉽게 구축
  - =>다루는 데이터가 많아졌다!
  - 애플리케이션의 기본 데이터를 안정적으로 추적하고 업데이트(렌더링, 추가, 삭제 등) 하는 도구 필요
  - =>애플리케이션의 상태를 변경할 때마다 일치하도록 ui 업데이트 필요
- 이 모든 걸 vanilla JS만으로는 쉽지 않다.
  - 페이지 갈때마다 모든 렌더링을 하기엔 서버 부하가 너무 커진다
### SPA (Single Page Application)
- 단일 페이지로 구성된 애플리케이션
- 하나의 HTML 파일로 시작하여, 사용자가 상호작용할 때마다 페이지 전체를 새로 로드하지 않고 **화면의 필요한 부분만 동적으로** 갱신
- 대부분 js 프레임워크를 사용하여 클라이언트 측에서 ui와 렌더링 관리
- =>csr 방식
- Client-side Rendering(CSR)
  - 클라이언트에서 화면을 렌더링하는 방식
- csr 동작 과정(p18)
  - 브라우저는 서버로부터 최소한의 html 페이지ㅗ아 해당 페이지에 필요한 js 응답받음
  - 클라이언트 측에서 js 사용해 dom 업데이트, 페이지 렌더링
  - 이후 서버는 더이상 html제공 x, 요청에 필요한 데이터만 응답
  - => google maps, facebook, instagram등에서 페이지 갱신 시 새로고침 없는 이유
- csr 필요한지 아닌지는 페이지에 따라 다름
- csr 장점
  - 빠른 페이지 전황
    - 페이지 첫 로드 후 필요한 데이터만 가져오면 됨. 전체 페이지 새로고침 필요 없이 일부만 다시 렌더링 가능
    - 서버 전송 데이터 최소화
  - 사용자 경험
    - 새로고침 없음. 네이티브 앱과 유사한 사용자 경험 제공
  - frontend, backend 명확한 분리
    - frontend는 ui렌더링 및 사용자 상호작용처리 담당, backend는 데이터 및 api 제공 담당.
    - 대규모 앱 더 쉽게 개발, 유지, 관리
- csr 단점
  - 느린 초기 로드 속도
    - 전체 페이지 보기 전에 약간의 지연
    - javascript가 다운로드, 구문 분석 및 실행될 때까지 페이지가 완전히 렌더링 되지 않음
  - seo(검색 엔진 최적화) 문제
    - 페이지를 나중에 그림 -> 검색에 잘 노출되지 않을 수 있음
    - 검색엔진 입장에서 html 읽어서 분석해야 하는데 아직 콘텐츠가 모두 존재하지 않음 
  - =>일부만 서버사이드로 바꿔주는 라이브러리: next.js(react), nuxt.js(vue)
- SPA vs MPA / CSR vs SSR
  - Multi Page Application(MPA)
    - 여러 개의 html 파일이 서버로부터 각각 로드
    - 사용자가 다른 페이지로 이동할 때마다 새로운 html 파일 로드
  - Server-Side Rendering
    - 서버에서 화면 렌더링
    - 모든 데이터가 담긴 html을 서버에서 완성 후 클라이언트에게 전달

# Vue
- 사용자 인터페이스를 구축하기 위한 js 프레임워크
## What is Vue
- Evan You에 의해 발표
- 최신버전은 vue3(2024). vue2문서에 접속하지 않도록 주의. ai 쓰면 특히 예전버전 많이나옴. 프롬프트 작성시 주의
- 초반엔 좀 불편.
### vue 체험하기
```html
<body>
  <div id="app">
    <!-- app객체에 있던 변수애들 쓸 수 있게됨 -->
    <h1>{{ message }}</h1>
    <button v-on:click="count++">
      <!--버튼 클릭하면 count 1증가-->
      <!--addEventListener 기타등등 다 여기서 처리-->
      <!--count++ 자리에 함수도 넣을 수 있다 -->
      Count is: {{ count }}
    </button>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script>
    const { createApp, ref } = Vue
    //vue.ref 이런식으로 쓰면 너무 불편해서 따로 할당한 것

    const app = createApp({ //객체 형태로 구현
      setup() { //앱에 사용할 데이터,함수 셋업
        const message = ref('Hello vue!')
        const count = ref(0)

        return { //내보낼애들 객체로 리턴
          message,
          count // 단축속성
        }
      }
    })

    app.mount('#app') //mount: 올라타다
    //app이란 객체를 html에서 id가 app인 녀석에 올라타게 할거임
    
  </script>
</body>
```
- ref는 무엇일까?
  
### vue의 2가지 핵심 기능
- 선언적 렌더링(Decalrative Rendering)
- 표준 html을 확장하는 템플릿 구문 사용, js 상태를 기반으로 화면에 출력될 html 선언적 작성
## Vue Style Guide
강의에서 걍 넘어갔으니 알아서 보고 정리
# Vue Tutorial
- cdn 방식
- npm 설치 방식
## cdn 설치 방식
```html 
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```
- cdn 작성
- application instance
  - cdn에서 vue를 사용하는 경우 vue 객체를 불러오게 됨
  - 구조분해할당 문법으로 vue 객체의 createApp 함수 할당
- 기타 교재보고 작성 40p

## 반응형 상태
### ref()
- 반응형 상태(데이터)를 선언하는 함수 (declaring reactive state)
- .value 속성이 있는 ref 객체로 래핑하여 반환
- ref로 선언된 변수의 값이 변경되면 해당 값을 사용하는 템플릿에서 자동으로 업데이트
- 인자는 아무타입 다 가능
- 어떻게? 는 getter, setter 알아야 하는데 너무딥하니 넘어감
- 템플릿의 참조에 접근하면 setup 함수에서 선언 및 반환 필요
- 편의상 템플릿에서 ref 사용시 .value 작성 필요 x
  - 원래 js에서 값뽑으려면 .value 해야하는데 vue 템플릿에서는 알아서 unwrap 해줌
- => 반응형을 가지는 참조 변수 만드는 것
### vue 기본 구조
### 템플릿 렌더링
- 화면에 렌더링할 때는 렌더링만 하자
### 이벤트 리스너
- 오늘안하고 내일한다. 그런게 있다만 기억
### ref 객체가 필요한 이유
- 교재보고 작성
# Single-File Components
- 하나의 html에 기능별로 다 집어넣으면 가독성이 구리다. -> 각 영역별로 컴포넌트 형태로 나눠서 관리
## Component
- 재사용 가능한 코드 블록
- ex. 유튜브 영상 카드 템플릿? 암튼 양식 통일된 것
### 특징
- ui를 독립적이고 재사용 가능한 일부분으로 분할, 각 부분을 개별적으로 다룸
  - 자연스럽게 애플리케이션이 중첩된 component tree 형태로 구성
### 예시
  - 웹 서비스는 여러 개의 component로 구성
## Single-File Components
- 컴포넌트의 템플릿, 로직 및 스타일을 하나의 파일로 묶어낸 특수한 파일 형식(.vue 파일)
- .vue 파일을 모듈처럼 불러옴
### SFC 파일 예시
- MyComponent.vue
```html
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'

const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```
- cosnt app = createApp{} 여기서 app을 vue파일 파일명(MyComponent)으로 바꿔서 집어넣어준다
- 나중에는 npm으로 필요한 모듈 가져와서 사용
- 프로젝트 단위로 관리
## SFC 문법
### 개요
-  각 *.vue 파일은 세가지 유형의 최상위 언어 블록
-  `<template>`, `<scirpt>`, `<style>`로 구성
-  언어 블록 작성 순서는 상관 없으나 일반적으로 는 template -> script -> style 순으로 작성
- 문법 추가는 교재보고 p64

### scoped
- 이 컴포넌트에만 이 스타일 적용할것이다
- 속성 따로 적는 이유
  - 컴포넌트 여러개인데 다 각자만의 스타일 존재.
  - 결국 렌더링되는 화면은 html 파일 하나.
  - 이 한장의 html에 컴포넌트 스타일이 다 적힘 -> 스타일시트의 명시도가 개판이난다
  - =>컴포넌트별로 스타일 제한한다고 명시
  - p134 참고
# Node
- Node.js: 크롬의 v8 js 엔진을 기반으로 하는 서버사이드 실행 환경
- 기존에 브라우저 안에서만 동작 가능했던 js를 브라우저가 아닌 서버 측에서도 실행할 수 있게 함
  - fn, bn에서 동일한 언어로 개발
### npm
## module
- 프로그램을 구성하는 독립적 카드 블록
### 필요성
- 크기가 커져서 파일 분리 -> 이걸 모듈이라고 부름
- .js 파일 하나가 하나의 모듈
- 앱이 발전하면서 처리해야 하는 모듈 개수 증가
- -> 성능 병목 현상, 모듈간 의존성 깊어짐 -> 특정한 곳에서 발전한 문제가 어떤 모듈 간의 문제인지 파악하기 어려움
  - 이 모듈 다 각각 개발자가 다를건데 버그 어케잡음??
  - 버전 호환성 문제 어캄??
- 의존성 문제를 해결하기 위한 도구 필요
  - bundler 등장
## bundler
- 여러 모듈과 파일을 하나(혹은 여러개)의 번들로 묶어 최적화 -> 애플리케이션에서 사용할 수 있게 만들어주는 도구
### 역할
- 의존성 관리, 코드 최적화, 리소스 관리 등
- bundler가 하는 작업 : bundling
- [참고] vite는 rollup이라는 bundler를 사용하며 개발자가 별도로 기타 환경설정에 신경 쓰지 않도록 모두 설정해두고 있음
# SFC build tool
## Vite
- 프론트엔드 개발 도구
  - 빠른 개발 환경을 위한 빌드 도구와 개발 서버 제공
## build
- 프로젝트의 소스 코드 최적화, 번들링 -> 배포할 수 있는 형식으로 변환하는 과정
- 개발중에 사용되는 여러 소스파일, 리소스를 최적화된 형태로 조합, 최종 소프트웨어 제품을 생성
### vite 튜토리얼
- terminal 에서 npm create vue@latest 입력
- 뭐 선택할거 많이뜸
  - router(나중에 배움)
  - pinia: 전체 상태관리(나중에 수업 중요)
  - 일단 오늘은 안씀. 
  - skip all example code and start with a blank Vue project : 실습할때는 yes. 첫날 구조알아보려면 no
  - 다음 하라는대로 npm 설치 등 
  - -> 테스트 가능한 로컬호스트 뜸 -> ctrl클릭                  
## 모듈과 번들러
# Vue 프로젝트
## 프로젝트 구조
### node_modules
- node.js 프로젝트에서 사용되는 외부 패키지들이 저장되는 디렉토리
- 프로젝트의 의존성 모듈을 저장하고 관리
- 프로젝트가 실행될 때 필요한 라이브러리와 패키지 포함
- gitignore에 작성됭
  - 공통적으로 저장되는 것이므로 git으로 관리될 필요 x
  - 노드 모듈만 50mb인데 10개만들면 500mb..
  - .gitignore 파일에 상대경로 적어두면 그건 git이 무시한다! node가 알아서 만들어준 파일.
### packaeg-lock.json
- 패키지들의 실제 설치 버전, 의존성 관계, 하위 패키지 등을 포함하여 패키지 설치에 필요한 모든 정보 포함
- npm install 할때 얘 기반으로 설치
### package.json
- 좀더 간단한 패키지 정보
- 프로젝트의 메타 정보, 의존성 패키지 목록
- 프로젝트 이름, 버전, 작성자, 라이선스 등과 같은 메타 정보 정의
- 실습하다보면 버전 안맞는거 있을텐데 터미널이 알려주는 명령어 치다 보면 알아서 해결됨
### src/components
- vue 컴포넌트들을 작성하는 곳. 그냥 명시적으로 사용함. 꼭 component에 없어도 된다. 기능별로 폴더 만들어서 분리하는 게 좋음
### src/App.vue
- root 컴포넌트
- 다른 하위 컴포넌트 포함
- 앱 전체의 레이아웃, 공통 요소 정의
- 도화지
### src/main.js
- vue 인스턴스 생성, 앱 초기화
- 메인 js 코드
- 필요한 라이브러리 import, 전역 설정 수행
### index.html
- 기본 html 파일
- 앱의 진입점
- 액자라고 생각
- app.vue가 해당 페이지에 마운트됨(mount)
  - vue 앱이 spa인 이유
- 필요한 스타일 시트, 스크립트 등 외부 리소스 로드 가능
  - bootstrap cdn 등
### 기타 설정 파일
- jsconfig.json
- vite.config.js
  - resolve:{alias...}
  - 뭐 막 복잡하게 모듈 참조할건데 alias 써서 좀 간단하게 부르기. src 폴더는 @라고 부릅시다!
  - 상대경로 ..으로 상위 폴더 가야 하거나 뭐 경로 복잡해진다 싶으면 src부터 절대경로 찾아야하는데 이때 @부터 시작하면됨
### 
### ㅁㄴㅇㄹ
- 나머지 폴더 교재보고 정리
- 실습도 한번 따라하기(주말)
- 컴포넌트 개많이만들건데 
  - 익스텐션 vue, vue vscode snippets 설치
  - crtl + shift + p
  - 나오는 검색창에서 snippes: Configure Snippets
  - vue.json
## Vue Component 활용
- 기억안나면 강의다시보고 실습
- 컴포넌트 불러와서 보여주고 싶은 영역에 두고 <컴포넌트명/>
- 노트에서 언급한 확장프로그램 깔면 웹에서 vue 어디컴포넌트인지 보여줌. 컴포넌트간 관계도 확인 

# 추가 주제
## composition api & option api
- vue를 작성하는 2가지 스타일
### composition api
- import 해서 가져온 api 함수 사용, 컴포넌트 로직 정의
- vue3 권장
- 메서드 이름 몇개 빼고 리액트랑 사용방식 유사
### option api
- data, methods, mounted 같은 객체 사용, 컴포넌트 로직 정의
- vue2 작성 방식. vue3에서도 지원하는데 권장 안함
- 좀 깔끔해보이는데 대신 this를 써야함
  - 방식을 다 찾아봐야해서 초반에 비추


