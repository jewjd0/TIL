# Component State Flow — Passing Props 요약

## Passing Props (상태 전달의 문제와 해법)
- 문제: 동일한 데이터(예: 프로필 이미지)를 여러 컴포넌트에서 각각 관리하면 변경 시 모든 컴포넌트에 대해 갱신 요청이 필요해 비효율적이다.
- 해법: 공통 부모 컴포넌트가 해당 상태를 한 곳에서 관리(상태 끌어올리기, "lift state up"). 부모가 상태를 받아 자식에게 props로 전달하고, 자식은 변경이 필요하면 부모에게 이벤트로 알린다(emit).
- 요약 흐름: 서버/상태 소스 → 최상위(공통) 부모(관리) → 자식들(props 전달). 자식은 자신에게 일어난 이벤트를 부모로 전달하여 부모가 상태를 업데이트한다.

## Props (정의와 특징)
- 정의: 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 속성(데이터).
- 주요 특징:
  - 단방향 바인딩(부모 → 자식): 데이터 흐름이 한 방향이므로 변화의 출처를 추적하기 쉽다.
  - 읽기 전용: 자식 내부에서 props를 직접 변경할 수 없다(변경은 부모가 수행).
  - 부모가 업데이트되면 전달된 props는 자동으로 갱신되어 자식에 반영된다.

## One-way data flow (단방향 데이터 흐름의 장점)
- 일관성: 데이터 변경이 어디서 발생하는지 명확하여 디버깅과 유지보수가 쉬워진다.
- 예측 가능성: 말단(하위) 컴포넌트가 상태를 임의로 변경하지 않으므로 전체 앱의 상태 흐름이 단순해진다.
- 중앙화: 공통된 상태는 부모가 한 번에 관리하므로 여러 자식에 대한 동기화가 쉬워진다.

## 왜 단방향인가? (구체적 이유)
- 데이터 변경의 출처를 쉽게 파악할 수 있다.
- 하위 컴포넌트가 실수로 상위 상태를 변경해 앱의 데이터 흐름을 복잡하게 만드는 걸 방지한다.
- 에러가 났을 때 문제의 범위를 좁히기 쉽다(상위에서 한 번에 관리).

## eventBus에 대한 언급
- `eventBus`(글로벌 이벤트 버스)는 props/emit 체인을 우회해 통신을 쉽게 해주지만, 유지보수성과 추적성이 떨어지므로 권장하지 않는다.

<!-- 끝: 'props 선언' 섹션 전까지 요약 완료 -->

## Props 세부사항
- Props Name Casing: HTML 템플릿에서 사용하는 속성 이름과 컴포넌트 내부에서의 속성 이름 표기(케밥-케이스 vs 카멜케이스 등)를 일관되게 사용한다.
- Static Props vs Dynamic Props:
  - Static Props: 문자열 리터럴처럼 고정 값 전달
  - Dynamic Props: 바인딩을 통해 반응형 값 전달 (예: `:` 또는 `v-bind` 사용)

## Props 활용
- 부모에서 속성을 전달하고, 자식은 받은 props를 읽기 전용으로 사용한다.
- 타입 지정은 문서/설명 수준에서 유용하지만, 런타임에서 엄격하게 강제되지 않을 수 있다(프레임워크 설정에 따라 다름).
- 스크립트 내부에서 props를 변수에 저장해 사용 가능하며, 템플릿에서는 그대로 출력하면 된다.

## Component Events (이벤트와 Emit)
- Emit: 자식이 부모에게 알릴 때 사용하는 패턴
  - 예: `$emit(eventName, ...args)` — 이벤트 이름과 추가 인자를 전달
- 이벤트 발신 및 수신:
  - 자식은 `$emit`으로 이벤트를 발생시키고, 부모는 `v-on`(또는 `@`)로 수신한다.
  - 모든 이벤트를 부모가 관리하게 되므로 이벤트 흐름 추적이 쉬워진다.
- `defineEmits()`:
  - 컴포지션 API에서 사용할 수 있는 선언형 도구로, 스크립트 내에서 사용할 emit 함수를 반환한다.
  - `props`와 유사하게 배열 또는 객체 형태로 이벤트 이름/타입을 선언할 수 있다.

## Computed Properties (계산된 속성)
- 정의: 다른 반응형 값에 의존해 계산되며, 결과를 캐싱하는 속성.
- 장점:
  - 동일한 계산을 여러 곳에서 사용해도 한 번만 계산(의존성 변할 때만 재계산)되어 성능 이득.
  - 반응형 의존성 자동 추적: 의존 데이터가 변경되면 자동 업데이트.
- Computed vs Methods:
  - Computed: 의존성 기반으로 결과를 캐싱해야 할 때 사용. getter/setter 개념 이해 필요.
  - Methods: 호출할 때마다 실행되며, 매번 재계산이 필요한 로직에 적합.

## Watchers (감시자)
- 역할: 하나 이상 반응형 데이터의 변화를 감지해 부수 효과(콜백)를 실행함.
- 사용 예: `watch(source, (newVal, oldVal) => { ... })` — `source`는 함수, ref, computed 등 가능.
- 여러 대상 감시: 배열 형태로 여러 소스를 감시할 수 있다.
- computed vs watch:
  - Computed: 계산된 값을 제공하고 캐싱함(재사용 목적).
  - Watch: 데이터 변화에 따른 작업(예: 비동기 호출, 로깅 등) 수행에 적합.

## 추가 (간단 정리)
- Lifecycle Hooks: `onMounted`, `onUpdated`, `onUnmounted` 등으로 인스턴스 생애주기 시점에 동작을 연결.
- Virtual DOM: 내부적으로 사용되는 렌더링 최적화 개념 — 개념 수준으로만 이해해도 충분.
