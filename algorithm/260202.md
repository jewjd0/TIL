# 재귀
## 재귀 함수
### 반복과 재귀
- 반복과 재귀는 유사한 작업 수행
- 반복은 수행 작업이 완료될 때까지 반복
- 재귀: 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해 이용
  - 재귀 함수로 구현
### 재귀 함수
- 함수 내부에서 직간접적으로 자기 자신을 호출하는 함수
- 재귀적 정의를 이용해 구현
  - 재귀적 정의: 자기 자신을 계속해서 호출
- 기본 부분, 유도 부분으로 구성
  - 기본 부분: 더 이상 재귀 호출하지 않고 결과를 반환하는 부분(종료 조건)
  - 유도 부분: 자기 자신을 호출하여 문제를 더 작은 문제로 나누는 부분(종료 조건에 도달하도록 유도)
- 반복 구조에 비해 간결, 이해 쉬움
- 메모리 구조에서 스택 사용
- 재귀 호출 : 반복적 스택 사용 -> 메모리, 속도 성능저하 발생
- for문 쓸때 인덱스 쓰는 연습 하기
- 점화식으로 표현 가능하면 재귀 함수로 구현 가능
  - 점화식: 수열의 항이 이전 항들에 의해 정의되는 식
  - 구조도를 그렸을 때 점화식이 나오면 그걸 바로 코드로 구현한 게 재귀 함수. 간결하다고 했지 빠르다곤 안함..
## 재귀 함수 예제
### 팩토리얼 재귀 함수
```python
def factorial(n):
    if n <= 1:          # 기본 부분
        return 1
    else:               # 유도 부분
        return n * factorial(n - 1)
```
- f(n) = n * f(n-1)
- 해들을 얻어 와서 문제를 해결하는 방식
### 피보나치 수열 재귀 함수
- 피보나치 수열: 이전의 두 수 합을 다음 항으로 하는 수열
```python
def fibonacci(n):
    if n <= 1:          # 기본 부분
        return n
    else:               # 유도 부분
        return fibonacci(n - 1) + fibonacci(n - 2)
```
- 이전에 계산된 값을 다시 계산하는 비효율성 존재. 낭비가 심함<br>
=> 메모이제이션 기법 사용 가능(dynamic programming에서 배우게 됨)
```python
def fibonacci_memoization(n):
    # n이 2 이상인데 계산된 적이 없어서
    # memo[n]의 값이 0이면 연산 수행
    if n >= 2 and memo[n] == 0:
        memo[n] = fibonacci_memoization(n-2) + fibonacci_memoization(n-1)
    return memo[n]


# 연산 결과 배열에 적어둠
# 이전에 해결한 적 있는 문제를 다시 계산하지 않도록 순서에 맞춰 어딘가 저장
# -> 충분히 큰 공간 필요
N = 10
memo = [0] * (N+1)
# append는 순서가 보장되어야 뒤에 추가 가능하므로 미리 리스트 만들어놓고 직접적으로 인덱스 지정해 입력
memo[0] = 0
memo[1] = 1
result = fibonacci_memoization(N)
```
- count 변수로 재귀 호출 횟수 세기 하면 memoization의 필요성 더 잘 느껴짐
  - global count 사용해서 재귀 호출 횟수 세기 가능
- 제약사항에 주어진 n의 범위에 따라 메모이제이션 필요 여부 판단
- 파이썬은 자체적으로 재귀 깊이 제한 존재(2000 정도)
### 하노이 탑 재귀 함수
- 세 개의 기둥과 서로 다른 크기의 원판 n개로 구성
- 원판으로 세 번째로 옮기는 것이 목표
- 한 번에 하나의 원판만 옮길 수 있음, 두 번째 기둥 이용 가능
- 큰 원판이 작은 원판 위에 놓일 수 없음
- 식: h(n) = 2^n-1 만큼 걸림
- f(n) = f(n-1) + 1 + f(n-1)
- 등비수열이라  2^n - 1
# 완전 탐색
## 베이비진 게임
### 베이비진 게임
- 0~9 숫자 카드 6장으로 베이비진 만들기
- 임의의 6장을 뽑았을 때 3장의 카드가 연속적인 번호를 갖는 경우 = run, 33장의 카드가 같은 번호를 갖는 경우 = triplet
- 6장의 카드를 3장씩 나누어 각각 run과 triplet으로만 구성된 경우 베이비진
- 6자리의 숫자를 입력받아 베이비진 여부 판단
### 완전 탐색
- 가능한 모든 경우의 수를 탐색하여 문제 해결
- bruteforce라고도 불림
- 경우의 수가 적을 때 효과적
- 대부분 문제에 적용 가능