# DP
## 개요
### 피보나치 수열
- 재귀 호출
  ```python
    def fib(n):
        if n < 2:
            return n
        return fib(n-1) + fib(n-2)
  ```
  - 엄청난 중복 호출 발생
- 메모이제이션
  - 컴퓨터 프로그램 실행 시 이전 계산 값을 메모리에 저장, 매번 다시 계산하지 않도록 하여 전체적인 실행속도 빠르게 하는 기술
  - 동적 계획법(Dynamic Programming)의 핵심
  - '메모리에 넣기'라는 의미. 기억되어야 하는 것이라는 뜻의 라틴어에서 파생
  ```python
    fibo1(n):
        if n >= 2 and memo[n] == 0:
            memo[n] = fibo1(n-1) + fibo1(n-2)
        return memo[n]
    num = 10
    memo = [0] * (num + 1)
    memo[0] = 0
    memo[1] = 1
    print(fibo1(num)) # 55
  ```
  - 하향식(top-down) 방식
  - 추가 메모리 공간 필요
  - 재귀 호출로 인해 스택 오버플로우 발생 가능
## DP(Dynamic Programming)
- 동적 계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
- 입력 크기 작은 부분 문제 해결, 해들을 이용하여 더 큰 크기의 부분 문제 해결, 최종적으로 원래 주어진 입력의 문제 해결하는 알고리즘
### 적용 요건
- 중복 부분문제 구조(overlapping subproblems)
  - 큰 문제를 이루는 작은 문제들 우선 해결, 작은 문제들의 최적 해를 이용하여 순환적으로 큰 문제 해결
    - 순환적 관계를 명시적 표현하기 위해 일반적으로 점화식 사용
  - 중복 부분문제 구조 -> 이전 계산되었던 작은 문제 해가 다른 곳에서 필요 => 이미 해결된 작은 문제들의 해들을 저장 공간(table)에 저장하여 재사용
  - 저장된 해들이 다시 필요할 때마다 재게산 없 이 table참조하여 중복 계산 방지
- 최적 부분문제 구조(optimal substructure)
  - 동적 계획법이 최적화에 대한 어느 문제에나 적용될 수 있는 것은 아님. 최적화의 원칙을 만족해야만 동적 계획법 효율적 적용 가능
  - 최적화 원칙: 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 함. 
  - 동적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적해들을 이용하여 구함 -> 만약 큰 문제의 최적해가 작은 문제들의 최적해들로 구성되지 않으면 동적 계획법 적용 불가
  - 최적 원칙 적용 불가 예 : 사이클 존재하는 최장경로 문제, 경로 이동 시 추가 비용 발생 문제 등
### 분할 정복 / 동적계획법
- 분할 정복
  - 연관 없는 부분 문제로 분할
  - 부분 문제 재귀적 해결
  - 부분 문제 해 결합
  - 예 : 병합 정렬, 퀵 정렬
  - 주로 하향식 접근
- 동적 계획법(DP)
  - 부분 문제들이 연관 없으면 적용 불가. 부분 문제는 더 작은 부분 문제 공유
  - 모든 부분 문제 한 번만 계산, 결과 저장 및 재사용
  - 부분 문제들 사이 의존 관계 존재
  - 관계는 문제에 따라 다르고, 대부분 문제간 의존성으로 인해 계산 우선순위 정해짐
  - 하향식, 상향식 접근 모두 가능
  - 상향식 설계를 통해 최적해를 구성하는 것이 특징
### 3단계 DP 적용 접근 방법
- 최적해 구조 특성 파악
  - 문제를 부분 문제로 분할
- 최적해 값 재귀적 정의
  - 부분 문제의 최적해 값 기반, 문제의 최적해 값 정의
- 상향식 방법으로 최적해 값 계산
  - 가장 작은 부분 문제부터 해 구한 뒤 테이블에 저장
  - 테이블에 저장되어 있는 부분 문제의 해 이용, 점차적으로 상위 부분 문제 최적해 구함(상향식)
## DP - 이항계수
- 이항정리
  - 이항 다항식 x+y의 거듭제곱 (x+y)^n에 대해, 전개한 각 항의 계수 값을 구하는 정리
  - 구체적으로 x^k * y^(n-k) 의 계수는 nCk로 표현, 이를 이항계수라고 함
- 공식 : nCk = n! / (k! * (n-k)!)
- 계산량 많은 n!, k! 계산 없이 이항계수를 구하기 위해 통상 다음 수식 사용 
  - if k = 0 or k = n: nCk = 1
  - else: nCk = (n-1)C(k-1) + (n-1)C(k)
- DP로 계산할 경우 파스칼의 삼각형 이용하여 계산
  - nCk = n-1Ck + n-1Ck-1
  - nC0 = 1, nCn = 1
## DP - 동전 거스름돈
- 거스름돈 문제
- 재귀적: n가지 동전 각각을 선택해 재귀적 해결
  - 각 동전 한 개를 선택, 남은 금액에 대한 최적해의 합
- DP적: 작은 금액부터 최적해 계산, 테이블에 저장
  - dp[i] = min(dp[i], dp[i - coin] + 1) for coin in coins if i >= coin