# 완전 탐색
## 순열(Permutation)
- 서로 다른 것 중 몇 개를 뽑아서 순서대로 나열하는 것
- 서로 다른 n개 중 r개를 택하여 일렬로 나열하는 경우의 수: nPr 
- nPr = n * (n-1) * (n-2) * ... * (n-r+1) = n! / (n-r)!
- nPn = n!
- 다수의 알고리즘 문제들은 순서화된 요소의 집합에서 최선을 찾는 방법과 관련됨
### 순열 생성(반복문)
- {1, 2, 3}을 포함하는 모든 순열 생성
```python
for i in range(1, 4):  
    for j in range(1, 4): 
        if j != i: 
            for k in range(1, 4):  
                if k != i and k != j:  
                    print(i, j, k)  
```
### 순열 생성(재귀 함수)
```python
def perm(selected, remain):  
    '''
    Args:
        selected: 선택된 값 목록
        reamin: 선택되지 않고 남은 값 목록 
    '''
    if not remain: # 남은 요소들 없으면 선택된 값 출력
        print(selected) # 선택된 요소들 출력
    else: # 남은 요소들 있는 경우
        for i in range(len(remain)): # 남은 요소들 인덱스 순회
            select_i = remain[i] # 남은 요소
            # 선택된 요소 제외, 새로운 남은 요소 리스트 생성
            # 인덱스 i 전까지 + 인덱스 i 이후 모두 합친 리스트 (즉, i번째 요소 제외)
            remain_list = remain[:i] + remain[i+1:] 
            # 선택한 요소 추가한 선택된 리스트, 남은 요소 리스트로 재귀 호출
            perm(selected + [select_i], remain_list)
# 초기 호출로 빈 리스트와 [1, 2, 3] 리스트 사용
perm([], [1, 2, 3])
```
## 조합(Combination)
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
- 서로 다른 n개 중 r개를 택하는 경우의 수: nCr
- nCr = n! / (r! * (n-r)!)
- nC0 = 1
- 하나 뽑았으면 걔는 배제시키고 생각
### 조합 생성(반복문)
- {1, 2, 3, 4}에서 3개를 뽑는 모든 조합 생성
```python
# i는 1에서 4까지의 값을 가지고, 첫 번째 자리의 숫자를 의미
for i in range(1, 5):
    # j는 i+1에서 4까지의 값을 가지고, 두 번째 자리의 숫자를 의미
    for j in range(i+1, 5):
        # k는 j+1에서 4까지의 값을 가지고, 세 번째 자리의 숫자를 의미
        for k in range(j+1, 5):
            # i, j, k가 서로 다른 세 숫자의 조합을 출력
            print(i, j, k)
```
### 조합 생성(재귀 함수)
```python

```

## 순열 조합 활용
- 좋은 만능코드 잘 기억해두기
```python
def comb(arr, n):
    result = []  # 조합을 저장할 리스트

    if n == 1:
        return [[i] for i in arr]

    for i in range(len(arr)):
        elem = arr[i]
        
        for rest in comb(arr[i + 1:], n - 1):  # 조합
        # for rest in comb(arr[:i] + arr[i+1:], n - 1):  # 순열
        # for rest in comb(arr, n - 1):  # 중복순열
        # for rest in comb(arr[i:], n - 1):  # 중복조합
            result.append([elem] + rest)

    return result

print(comb([1, 2, 3, 4], 3))
```
## 부분 집합(반복, 재귀)
- 집합에 포함된 원소들 선택
- 원소들 그룹에서 최적의 부분 집합 찾기 많이 사용
- n개의 원소 있는 집합에서 공집합 포함한 모든 부분 집합의 개수: 2^n
- 각 원소를 부분집합에 포함하거나 포함하지 않거나 2가지를 모든 원소에 적용
### 부분집합 생성(반복문)
- {1, 2, 3}의 모든 부분집합 생성
```python
# 3개의 선택된 값을 저장할 리스트 초기화
selected = [0] * 3

# i, j, m은 각각 첫 번째, 두 번째, 세 번째 선택된 값을 나타냄
for i in range(2):
    selected[0] = i # 첫 번째 값 설정
    for j in range(2):
        selected[1] = j # 두 번째 값 설정
        for m in range(2):
            selected[2] = m # 세 번째 값 설정
            subset = [] # 부분 집합을 저장할 리스트 초기화
            for n in range(3): # selected 리스트의 각 요소에 대해 반복
                if selected[n] == 1: # 요소가 1인 경우 (값이 설정된 경우)
                    subset.append(n+1) # 부분 집합

            print(subset) # 현재 부분 집합 출력
```
### 부분집합 생성(재귀 함수)
```python
def create_subset(depth, included):
    '''
     Args:
        depth: 현재 깊이 (처리 중인 요소의 인덱스)
        included: 각 요소가 부분 집합에 포함되는지 여부를 나타내는 불리언 리스트
    '''
    if depth == len(arr):
        # 포함할지 안할지에 대한 bool 리스트를 적용해 subset 제작
        # cnt_subset = [arr[i] for i in range(len(arr)) if included[i]]
        # subsets.append(cnt_subset)
        cnt_subset = []
        for i in range(len(arr)):
            if included[i] == 1:
                cnt_subset.append(arr[i])
        subsets.append(cnt_subset)
        return

    included[depth] = 0
    create_subset(depth+1, included)

    included[depth] = 1
    create_subset(depth+1, included)

    
arr = [1, 2, 3] # 부분 집합을 생성할 입력 리스트
subsets = [] # 모든 부분 집합을 저장할 리스트
init_included = [0] * len(arr) # 각 요소의 포함 여부를 저장할 리스트 초기화
create_subset(0, init_included) 
print(subsets)
```
## 부분집합(바이너리 카운팅)
- 들어갈지 말지는 0, 1로 표현하는데 그냥 2진수 계산하는 게 빠름
- 결국 경우의 수 구하는거라 오래걸리긴함. 그나마 빨리하기가 목적
- 오늘 쓸건 &, << 연산자
- & : 비트 단위 AND 연산자
- << : 비트 단위 왼쪽 시프트 연산자(남는자리 0으로 채움)
- 부분집합 모든 경우의 수 2^n개는 1을 n번 왼쪽 시프트한 값과 같음
- 비트연산 쓰는법 인지하고 있을 것