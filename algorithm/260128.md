# Classes

## 객체
### Class
- 파이썬에서 타입 표현 방법<br>
=> 객체 생성 설계도<br>
=> 데이터와 기능 함께 묶는 방법 제공
### 객체
- 클래스에서 정의한 것을 토대로 메모리에 할당된 것
- 속성과 행동으로 구성된 모든 것
### 클래스와 객체
- 클래스로 만든 객체 = 인스턴스
- 클래스를 만든다 == 타입을 만든다
```python
name = 'Alice'
print(type(name))  # <class 'str'>
```
- 변수 name은 **str 클래스**의 인스턴스
- 무엇의 인스턴스인지를 명확하게 알 것.
- 인스턴스.메서드()로 메서드 사용
### 하나의 객체는 특정 타입의 인스턴스
- 2, 35, -1.5는 모두 숫자 타입의 인스턴스
- 'hello', "world", ""는 모두 문자열 타입의 인스턴스
- [1, 2, 3], ['a', 'b', 'c'], []는 모두 리스트 타입의 인스턴스
### 객체 정리
- 타입(type): 어떤 연산자(operator)와 조작(method)이 가능한가?
- 속성(attribute): 어떤 상태(데이터)를 가지는가?
- 조작법(method): 어떤 행위(함수)를 할 수 있는가?

## 클래스
### 개요
- 객체를 생성하기 위한 설계도
- 데이터와 기능을 함께 묶는 방법 제공
### 클래스 정의
- class 키워드 사용
- 파스칼 케이스(PascalCase) 사용
```python
class Person:
    blood_color = 'red'
  def __init__(self, name):
    self.name = name
  def singing(self):
    return f'{self.name}가 노래합니다.'
```
### 인스턴스 생성 및 활용
- 클래스를 호출하여 인스턴스 생성
```python
# 인스턴스 생성
singer1 = Person('iu')
# 메서드 호출
print(singer1.singing())  
# 속성(변수) 접근
print(singer1.blood_color)
```

## 클래스 구성요소
### 생성자
- 객체 생성 시 자동으로 호출되는 메서드
- `__init__` 메서드로 정의, 객체 초기화 담당
- 인스턴스 생성, 필요한 초기값 설정
- 꼭 self 매개변수 포함
  - self: 생성된 인스턴스 자신을 가리키는 매개변수
  - 함수 호출시에 자동으로 전달됨(매개변수로 넘겨줄 필요 없음)
  ```python
  def __init__(self, name):
    self.name = name
  ```
### 인스턴스 변수
- 인스턴스마다 별도로 유지
- 인스턴스마다 독립적인 값, 인스턴스 생성 시 초기화
### 클래스 변수
- 클래스에 내부에 선언된 변수
- 모든 인스턴스가 공유
- 인스턴스가 아닌 클래스 이름으로 접근 가능
### 인스턴스 메서드
- 각 인스턴스에서 호출 가능
- 인스턴스 변수에 접근, 수정 등
- 인스턴스에는 속성이 우선 저장됨.
  - 인스턴스 메서드가 호출되어 와서 self에 호출한 대상 인스턴스가 할당, 실행된다 => 메모리 공간 절약, 함수 재사용
  - 인스턴스 변수는 나만의 값을 가지는 형
## 인스턴스 변수와 클래스 변수
- 인스턴스 생성될 때마다 클래스 변수가 늘어나게 설정 가능
- class.class_variable 로 변수 참조 가능
- 클래스로 클래스 변수 접근해 변경 시 모든 인스턴스에 영향
- 인스턴스로 클래스 변수 접근해 변경 시 해당 인스턴스에만 영향
  - 새 인스턴스 변수가 생성됨
```python
class Circle:
    pi = 3.14  # 클래스 변수
    def __init__(self, r):
        self.r = r  # 인스턴스 변수
c1 = Circle(5)
c2 = Circle(10)

print(c1.pi)  # 3.14
print(c2.pi)  # 3.14

Circle.pi = 3.14159  # 클래스 변수 변경
print(c1.pi)  # 3.14159
print(c2.pi)  # 3.14159
c2.pi = 3.14  # c2 인스턴스에 새로운 pi 속성 추가
print(c1.pi)  # 3.14159
print(c2.pi)  # 3.14
#더이상 c2 인스턴스로는 클래스 변수 pi에 접근 불가
``` 
- 파이썬의 기본 원칙은 "바보짓을 안하면 된다" 그냥 알아서 조심하기
- 인스턴스에 클래스 변수와 같은 이름의 속성 추가되면 더이상 해당 인스턴스로는 클래스 변수에 접근 못함
- 클래스 생성자에 존재하지 않는 변수 임의 생성, 할당
  - 매우 위험
  - 클래스 설계 의도와 다르게 동작할 수 있음 

## 메서드
### 개요
- 클래스 내부에 정의된 함수
- 인스턴스 메서드, 클래스 메서드, 정적(static) 메서드
### 인스턴스 메서드
- 클래스로부터 생성된 인스턴스에서 호출 가능한 메서드
  - 인스턴스 상태 조작, 동작 수행
- 첫 번째 매개변수로 반드시 self 사용
  - self이름 필수는 아님, 관례적으로 self 사용
- self 동작 원리
  - class.instance_method(args) 형태로 내부 동작
### 클래스 메서드
- 클래스 자체에서 호출 가능한 메서드
- @classmethod 데코레이터 사용
- 첫 번째 매개변수로 cls 사용
  - cls: 클래스 자신을 가리키는 매개변수
```python
class Person:
  count = 0
  def __init__(self, name):
    self.name = name
    Person.count += 1
  @classmethod
  def number_of_population(cls):
    print(f'인구수는 {cls.count}입니다.')

person1 = Person('iu')
person2 = Person('BTS')
Person.number_of_population()  # 인구수는 2입니다.
```
- 주의점
  - 클래스 메서드는 인스턴스에서 호출 가능
  - 가능해도 하지마라 (명시적 약속이므로 권장x)
  - 메서드 사용할 때 확인하고 할 것
### 정적 메서드
- 클래스나 인스턴스 상태와 무관하게 독립적으로 동작하는 메서드
  - 주로 클래스와 관련있으나, 인스턴스와 상호작용이 필요 없는 경우
- @staticmethod 데코레이터 사용
- 매개변수로 self, cls 없음
```python
class StringUtils:
    @staticmethod
    def reverse_string(string):
        return string[::-1]
    @staticmethod
    def capitalize_string(string):
        return string.capitalize()

text = 'hello, world'
reversed_text = StringUtils.reverse_string(text)
print(reversed_text)  # dlrow ,olleh
capitalized_text = StringUtils.capitalize_string(text)
print(capitalized_text)  # Hello, world
```
- 왜필요한가?
  - self, cls 필요없는 함수라도 클래스 내부에 묶어두고 싶을 때
## 인스턴스와 클래스 간 이름 공간
- 클래스 정의 시 클래스와 해당 이름 공간 생성
- 인스턴스 생성 시 인스턴스 객체 생성, 독립적 이름 공간 생성
- 인스턴스에서 특정 속성에 접근시 인스턴스->클래스 순으로 탐색
- LEGB 규칙 알아둘 것
## 상속
- 기존 클래스(부모 클래스, 슈퍼 클래스)를 기반으로 새로운 클래스(자식 클래스, 서브 클래스) 생성
- 코드 재사용, 확장성 향상
- 상속 없이 구현하면 메서드 중복 발생
```python
lass Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def talk(self):  # 메서드 재사용
        print(f'반갑습니다. {self.name}입니다.')
class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department
class Student(Person):
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa

p1 = Professor('박교수', 49, '컴퓨터공학과')
s1 = Student('김학생', 20, 3.5)
# 부모 Person 클래스의 talk 메서드를 활용
p1.talk()  # 반갑습니다. 박교수입니다.
# 부모 Person 클래스의 talk 메서드를 활용
s1.talk()  # 반갑습니다. 김학생입니다.
```
### 다중 상속
- 파이썬은 다중 상속 지원
- 여러 부모 클래스로부터 상속 가능
- 상속받은 모든 클래스의 요소 활용 가능
- 중복 속성, 메서드 있는 경우 **상속 순서에 따라 결정**
```python
class Person:
    def __init__(self, name):
        self.name = name
    def greeting(self):
        return f'안녕, {self.name}'
class Mom(Person):
    gene = 'XX'
    def swim(self):
        return '엄마가 수영'
class Dad(Person):
    gene = 'XY'
    def walk(self):
        return '아빠가 걷기'

class FirstChild(Dad, Mom):
    def swim(self):
        return '첫째가 수영'
    def cry(self):
        return '첫째가 응애'
baby1 = FirstChild('아가')
print(baby1.cry())  # 첫째가 응애
print(baby1.swim())  # 첫째가 수영
# swim 아가 클래스에 없으면 '엄마가 수영'으로 출력됨
print(baby1.walk())  # 아빠가 걷기
print(baby1.gene)  # XY
# 아빠가 먼저 상속되었으므로 dad의 gene 사용
```
- 다이아몬드 문제(59p)
  - c3 선형화 문제 
  - 두 클래스가 동일한 조상을 가질 때 발생
  - A: 부모 클래스 [A, object]
  - B, C: A를 상속받는 자식 클래스 [B, A, object], [C, A, object]
  - D: B, C를 상속받는 자식 클래스 D + [B,A,o]+[C,A,o]
  - D는 b의메서드 중 어떤 버전 상속? 혹은 c의 메서드 상속?
  - 뭔말이지?
  - 머리가 아닌 위치에 뭐라고?
  - 파이썬은 C3 선형화 알고리즘 사용
  - MRO(method resolution order) 사용
  - 계층 구조에서 겹치는 같은 클래스 두번 검색x
  - 속성이 d에서 발견되지 않으면 b->c->a->object 순으로 검색
  - 막 외울필요는 없고 알고리즘이 왜필요한가에 대한 설명
  - 언제나 같은 상황에서 같은 결과가 나오게 로직 짜여져 있음
  - `__mro__` 속성이나 `mro()` 메서드로 확인 가능
### super()
- 부모 클래스의 메서드 호출하는 내장 함수
- 다중 상속 시 mro 기반으로 현재 클래스가 상속하는 모든 부모 클래스 중 다음에 호출될 메서드 결정, 자동 호출
- 파이썬에는 오버로딩이 없다.
```python
# 단일 상속
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email

class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        # Person의 init 메서드 호출
        super().__init__(name, age, number, email)
        self.student_id = student_id
        # 추가로 있는 student_id만 초기화
```
```python
# 다중 상속
class ParentA:
    def __init__(self):
        self.value_a = 'ParentA'
    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')
class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'
    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')

class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__() # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'
    def show_value(self):
        super().show_value() # ParentA 클래스의 show_value 메서드 호출
        print(f'Value from Child: {self.value_c}')
```
- ParentB의 생성자는 Child에서 호출이 불가한가?
  - parentA에서 super() 호출하면 parentB의 생성자 호출 가능
  - 왜지??
  - parentA를 그냥 생성하면 거기서 obj 호출
  - child에서 호출한 parnetA의 super()가 parentB 호출
  - mro에 따라 호출됨
  - 그럼 super.super같은건 안되는거임?
  - parentA에서 인스턴스 만들면 그 super는 object 호출
  - child에서 parentA 생성자 호출하면 parentA의 super는 parentB 호출
  - 이런복잡한;
  - 상속에 상속할 super 고려해서 만들어야 한다. 
  - 너무 복잡하게 만들지 않도록 유의

## 클래스 참고
### 메서드 주의사항
- 클래스가 사용 : 클래스 메서드, 스태틱 메서드
- 인스턴스가 사용 :  인스턴스 메서드
- 클래스 메서드, 스태틱 메서드는 인스턴스에서 호출 가능은 하지만 권장x
- 클래스는 모든 메서드 호출 가능
  - 클래스는 클래스 메서드, 스태틱 메서드만 호출 권장
- 인스턴스는 모든 메서드 호출 가능
  - 인스턴스는 인스턴스 메서드만 호출 권장
### 할수 있다 != 써도 된다

### 매직 메서드
- 인스턴스 메서드
- 특정 상황에 자동 호출
- `__init__`, `__str__`, `__repr__`, `__add__`, `__len__` 등 `__`로 시작하고 끝나는 메서드
- 예시
  - `__str__`: print() 함수로 객체 출력 시 호출
## 에러, 예외 처리
- 교재 참고
## 모듈, 패키지
- 교재 참고
## 참고
- 파이썬은 문자열 크기비교 가능 (아스키코드 크기순)
- a = 97