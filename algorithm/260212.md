# 서로소 집합
### 개요
- 서로소 혹은 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합</br>
 => 교집합 없음
- 두 집합 간 공통 원소가 없을 때, 두 집합은 서로소 집합이라고 함
- 집합에 속한 하나의 특정 원소를 통해 각 집합 구분 -> 대표자(representative)라 부름
- 표현 방법
  - 연결 리스트 
  - 트리
- 연산
  - Make-Set(x): 원소 x에 대해 새로운 집합을 생성
  - Find-Set(x): 원소 x가 속한 집합의 대표자 반환 
  - Union(x, y): 원소 x와 y가 속한 두 집합을 하나의 집합으로 합침
- 원소 하나인 집합을 union 연산을 통해 합쳐나가는 방식으로 집합 생성
## 서로소 집합 표현
### 트리
- 같은 집합의 원소 하나의 트리로 표현
- 자식 노드 -> 부모 노드 가리키며 루트 노드가 대표자
### 연결 리스트
- 같은 집합의 원소들을 연결 리스트로 표현
- 각 원소는 집합의 대표자를 가리킴

### 리스트
- 트리, 연결 리스트 -> 파이썬 리스트로 구현. 
- 각 원소에 리스트로 값, 가리키는 대표자 정보 저장

## 서로소 집합 연산
### Make-Set(x)
- 유일한 멤버 x를 포함하는 새로운 집합 생성
- 각 인덱스가 값, 값이 대표자 가리키는 역할
- 초기 상태에서 각 원소는 자기 자신을 대표자로 가리킴
```python
def make_set(x):
    return [i for i in range(x+1)]
```
### Find-Set(x)
- x를 포함하는 집합 찾는 연산(대표자 반환)
```python
def find_set(x):
    if parent[x] == x:
        return x # 대표자면 반환
    # 대표자 아니면 재귀 호출로 찾기
    return find_set(parent[x])
```
### Union(x, y)
- x, y를 포함하는 두 집합을 하나로 합치는 연산
```python
def union(x, y):
    x_root = find_set(x)
    y_root = find_set(y)
    if x_root != y_root:
        parent[y_root] = x_root
```

### 서로소 집합 연산의 문제점
- 편향 트리가 형성될 수 있음
- 최악의 경우, 트리의 높이가 n이 되어 Find-Set 연산이 O(n)의 시간 복잡도를 가짐
- -> 제일 아래 있는 노드가 모든 노드를 순회해 대표자에 도달할 수 도 있음

## 서로소 집합 최적화
### 경로 압축(Path Compression)
- Find-Set 연산 시, 탐색 경로 상의 모든 노드를 대표자에 직접 연결
- 이후 Find-Set 연산 시 시간 단축
- path compression 적용한 연산은 특정 노드에서 루트까지의 경로를 찾아 가며 부모 노드 갱신
- 장점
  - 루트를 빨리 찾음
- 단점
  - parent가 모두 루트를 가리켜버림
  - 트리 부모도 찾아야 하고 대표자도 찾아야 하면 리스트를 2개 쓰거나 튜플로 관리해야 함
- -> 무조건 쓰는 거 아니고 상황에 따라 선택할 것
### 랭크(높이) 기반 합치기(Union by Rank)
  - 각 노드는 자신을 루트로 하는 서브트리의 높이를 랭크로 저장
  - 루트 랭크 : 0
  - Union 연산 시, 랭크가 낮은 트리를 랭크가 높은 트리 밑에 붙임
    - 랭크 낮은 트리를 밑에 붙여야 트리 자체의 랭크 변화가 적음
    - 랭크가 같으면 그냥 1 증가해야지 어쩌겠어 먼저 들어온 애가 루트, 랭크 1 증가
### 경로 압축은 언제 일어날까?
- Find-Set 호출 시 해당 경로만 on demand로 최적화
- 경로 압축은 union 연산의 기능이 아님
- union이 내부적으로 find_set을 호출하므로 union 연산 시에도 경로 압축이 일어남 (부수 효과)
- 자료구조를 사용할 때마다, 필요한 부분 자동으로, 점진적으로 최적화
- 별도로 압축 호출 필요 없이, 자료구조 사용하면 전체 트리가 효율적인 구조로 개선


## 참고
### 서로소 집합 - 연결 리스트
- 같은 집합 원소들은 하나의 연결 리스트로 관리
- 연결 리스트 맨 앞의 원소 = 대표 원소
- 각 원소는 집합 대표원소를 가리키는 링크 가짐
- 노드를 클래스로 정의해서 사용
### 추가
- 개념이 복잡한 코드는 아님. 사용 용도가 너무 많음
- 이진트리가 아닌 상황에서 조상이 누군지 아는 방법을 알게 되었다!
- 네?
- c와 e가 최초로 동시에 만나는 부분에서 끊으면 가장 작은 서브트리가 만들어짐
- 꽤 많이 쓰일 예정이니 코드 쓰는 법, 개념 꼭 이해해두기!!
