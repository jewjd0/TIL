# 스택
## 스택의 구조, 작동원리
### 스택
- **물건을 쌓아 올리듯** 자료를 쌓아 올린 형태의 자료구조
- 스택 저장된 자료는 선형구조를 가짐
  - 선형 구조: 데이터 요소 사이에 순서 존재
  - 비선형 구조: 데이터 요소 사이에 순서 존재하지 않음
- 스택에 자료 삽입, 자료 꺼내기 가능
- 후입선출 (LIFO, Last In First Out) 구조
  - 가장 나중에 삽입된 자료가 가장 먼저 꺼내짐
## 주요 연산
- push: 스택에 자료 삽입
- pop: 스택에서 자료 꺼내기
  - 꺼낸 자료는 삽입한 순서의 역순
- peek (또는 top): 스택의 맨 위에 있는 자료 확인
  -top: 스택에 저장된 원소 중 마지막 원소
- isEmpty: 스택이 비어있는지 확인
### 구현
- 파이썬에서 스택은 pop()과 append() 메서드를 사용하는 리스트로 쉽게 구현 가능
- 클래스 형태로 스택 구현 예시
```python
# 샘플코드에 구현함
```
- 사실 스택은 리스트 쓰면 된다
## 스택 응용
### 괄호 검사
- 괄호끼리의 짝이 맞는지 검사
- 여는 괄호를 만나면 스택에 push
- 닫는 괄호를 만나면 스택에서 pop하여 짝이 맞는지 확인
- 모든 문자를 처리한 후 스택이 비어있으면 짝이 맞음
- 스택이 비어있지 않으면 짝이 맞지 않음
### 중위 표기식 -> 후위 표기식 변환
- 후위 표기식: 연산자가 피연산자 뒤에 위치하는 표기법
- 중위 표기식: 연산자가 피연산자 사이에 위치하는 표기법
- 뭔말이지? -> 중위 표기법은 다음 연산자를 만났을 때 연산을 언제할지? 컴퓨터가 계산을 못한다는 듯?
- 후위 표기법은 연산자가 피연산자 뒤에 위치하므로 컴퓨터가 계산하기 쉬움
- 연산자를 만나면 마지막으로 만난 피연산자 두개를 꺼내서 연산. 결과를 다시 스택에 push
- 실습에 계산기1 문제 풀기
# 큐
## 큐의 구조, 작동원리
### 큐
- 삽입과 삭제의 위치가 제한적인 자료구조
  - 큐의 뒤에서는 삽입만, 앞으로는 삭제만 가능
- 선입선출 (FIFO, First In First Out) 구조
  - 가장 먼저 삽입된 자료가 가장 먼저 꺼내짐
- 줄 서기와 비슷한 개념
### 주요 연산
- enqueue: 큐에 자료 삽입
- dequeue: 큐에서 자료 꺼내기
  - 꺼낸 자료는 삽입한 순서와 동일한 순서
- isEmpty: 큐가 비어있는지 확인
- peek (또는 front): 큐의 맨 앞에 있는 자료 확인
  - front: 큐에 저장된 원소 중 첫 번째 원소
  - rear: 큐에 저장된 원소 중 마지막 원소
### 구현
- 구현했을 때 front는 첫 원소가 아니라 그 앞에 빈 공간을 가리킴
    - dequeue 할때 front++ 하고 제거하기 때문
- 근데 굳이 그래야 하나? front, rear이 둘다 0 가리키고 있으면 빈거 취급인데 둘다 0 가리키고 값 들어오면 front가 계속 첫 원소를 바로 가리키게 하는 게 peek를 받기도 편하지 않나? 값 들어온다고 front가 바뀌는것도 아니고 rear만 움직이는데
  - circular queue 코드 isempty 도 이상한디 -1이면 빈걸로치고
  - 그냥 stack랑 코드 통일하고 싶으셨나?
  - 아니다 그냥 -1이 맞는듯..? 자료 하나만 있을 때 rear랑 front가 같아지니까 
- 큐 구현은 pop, append로는 너무 느림
  - 앞에 있는 원소를 제거할 때마다 모든 원소를 한 칸씩 앞으로 이동시켜야 하기 때문
### 거짓 포화
- 큐가 가득 찼다고 판단되는 상황
- 실제로는 빈 공간이 남아있음
- 리스트 크기가 정해져있는 상태에서 선형으로 사용해 front가 감소하는 일 없이 계속 증가하면 발생
## 원형 큐
- 선형 큐의 거짓 포화를 해결하기 위한 방법
- 리스트의 끝과 처음이 연결된 형태
- 유사 원형처럼 써서 빈 공간을 효율적으로 활용
- front와 rear가 리스트의 끝에 도달하면 다시 처음으로 돌아감
- 사이즈로 나눈 나머지를 인덱스로 사용
## 파이썬의 deque
- collections 모듈의 deque 클래스 사용
- append, popleft사용하면 됨
- 사실 평소푸는 문제는 그냥 pop(0) 써도 됨
- 시간복잡도 문제는 아님. O(n)이 작아서 큰 영향 없음

## 연결 리스트
- 지금 구현할 일 없음
- 파이썬 리스트 그냥 쓰기. 개념 알고만 있어라
### 개요
- 자료 삽입/삭제 과정에서 연속적인 메모리 배열을 위해 원소 이동 작업 필요.
- 원소 개수 많고 삽입/삭제 빈번하면 작업 소요 시간 크게 증가
- => 링크를 통해 원소들이 메모리 상에 비연속적으로 존재하도록 함
## 연결 리스트
- 메모리 상 물리적 순서와 논리적 순서 분리
- 각 원소가 데이터와 다음 원소에 대한 참조(링크)를 포함하는 노드로 구성
- 자료구조 크기 동적 조정 가능 => 메모리 효율적 사용
- 링크를 통해 접근 => 리스트처럼 물리적 순서를 맞추는 작업 불필요
### 단순 연결 리스트
- 단방향 참조
### 이중 연결 리스트
- 양방향 참조
- 두개의 링크, 한개의 데이터 필드
- 복잡스
- 그런게 있다 정도로 기억

### 데이터 타입과 데이터 구조는 다르다
- 데이터 타입: 데이터의 종류와 특성을 정의
- 데이터 구조: 데이터를 저장하고 조직하는 방법