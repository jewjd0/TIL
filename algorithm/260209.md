# BFS
- 루트 노드의 자식 노드들을 먼저 모두 차례로 방문한 후, 방문했던 자식 노드들을 기준으로 하여 다시 해당 노드의 자식 노드들을 차례로 방문하는 방식
- 인접한 노드들에 대해 탐색한 후, 차례로 다시 너비우선탐색 진행, 선입선출 형태의 자료구조 큐 활용
- queue 사용. 
- FIFO 특성 이용할 것 
- 그럼 깊이만큼 큐가 생기나?
- 먼저들어온 애를 빼면 너비우선, 나중에 들어온 애를 먼저빼면 깊이우선
- bfs는 유감 재귀가 안된다에요
- 함수 만들때 무조건 dfs bfs라고 함수명 적지 않기..
## BFS - 트리
```python
def bfs_tree(node):
    '''
    조사 대상 후보군 큐에 삽입
    조사 시작시 
    큐에서 fifo 하여 다음 후보 노드 얻기
        이 시점이, 해당 노드를 방문하였다!로 판단 
    그 노드를 루트로 하여, 다음 이동 가능한 후보군(자식 노드들)을 큐에 삽입
    :param node: 조사 시작 노드
    :return: 탐색 경로
    '''
    queue = [node]
    result = []
    while queue:
        node = queue.pop(0) # FIFO
        result.append(node) # 방문 처리
        for child in graph[node]:
            queue.append(child)
    return result
```
- 단점: pop(0)이 비효율적
- 파이썬 deque쓰면됨

## BFS - 그래프
- 얘도 사이클이 문제임 또 visited를 써
- 코드를 너무 외우지 말것
```python
def bfs(node):
    queue = deque([node])
    result = []
    # visited는 set 혹은 [0 or False] 배열로 선언 가능한데 뭐가 나은지는 상황따라 다름
    visited = set()
    # 후보군에 노드가 삽입된 순간 -> 미래 언젠가 방문할 것
    visited.add(node)
    while queue:
        node = queue.popleft()
        result.append(node)

        for next in range(7):  # 노드 개수만큼 반복
            if adj_mat[node][next] and next not in visited:
                queue.append(next)
                visited.add(next)

    return result
```
- 최소시간, 최단거리 문제를 풀 때 dfs보다 bfs가 유리
- 다음 후보군에 지금까지의 비용은 변하지 않고 지금 위치를 기준으로 다음 위치를 넣을거라 bfs 사용하는 것.