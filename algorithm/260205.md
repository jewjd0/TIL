# 트리
- 비선형 구조
- 원소들 간에 1:N 관계
- 계층 관계를 가지는 계층형 자료구조
- 상위 원소에서 하위 원소로 내려가며 확장되는 트리 모양의 구조
- DOM 트리에서 배웠던거
## 정의
- 한개 이상의 노드로 이루어진 유한 집합
  - 최상위 노드: 루트 노드
  - 나머지 노드들은 n개의 분리 집합으로 분리될 수 있음
- 각 분리 집합도 트리
  - 재귀적 정의하여 루트의 부 트리라 부름
## 용어 정리
### 노드 (Node)
- 노드 (Node): 트리를 구성하는 각 원소
- 간선 (Edge): 노드 간의 연결선
- 루트 노드 (Root Node): 트리의 최상위 노드
- 부모 노드 (Parent Node): 하위 노드를 가지는 노드
- 형제 노드 (Sibling Node): 같은 부모를 가지는 노드들
- 자식 노드 (Child Node): 부모 노드에 연결된 하위 노드
- 조상 노드 (Ancestor Node): 간선을 따라 루트 노드까지 올라가는 경로에 있는 노드들
- 자손 노드 (Descendant Node): 특정 노드의 하위 노드들
- 서브 트리 (Subtree): 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
### 차수
- 노드의 차수 (Degree): 해당 노드가 가지는 자식 노드의 개수
- 트리의 차수: 트리 내에서 가장 큰 차수를 가진 노드의 차수
- 단말 노드 (Leaf Node): 자식 노드가 없는 노드
### 레벨과 높이
- 노드의 레벨 (Level): 루트 노드로부터의 거리 (루트 노드의 레벨은 0)
  - 교재에 따라 루트 노드를 1로 잡기도 함. 직접 쓸땐 통일해주기
- 트리의 높이 (Height): 트리 내에서 가장 깊은 노드의 레벨. 즉, 루트 노드에서 가장 먼 단말 노드까지의 거리
## 이진 트리
- 차수가 2인 트리
- 각 노드가 최대 두 개의 자식 노드를 가질 수 있음
- 모든 노드들이 최대 두 개의 서브 트리를 가짐
### 특성
- 레벨 i에서의 최대 노드 수: 2^i (i는 0부터 시작)
- 높이 h인 이진 트리의 최소 노드 수: h + 1
- 높이 h인 이진 트리의 최대 노드 수: 2^(h+1) - 1
### 포화 이진 트리
- 모든 레벨에 노드가 완전히 채워진 이진 트리
### 완전 이진 트리
- 마지막 레벨을 제외한 모든 레벨이 완전히 채워진 이진 트리
- 마지막 레벨의 노드는 끝까지 다 안 채워져도 중간 노드는 다 채워짐
- 높이가 h이고 노드 수가 n일 때 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 10개가 있는 노드면 5번까지 탐색하면 됨. 5번이 마지막 10번노드 하나만 가지고 있음.
- 완전 이진 트리 조건 : 높이 h이고 노드 수 n일 때 (2^(h) < n <= 2^(h+1) -1)(루트 레벨 0 기준)
  - 루트 레벨 1 기준이면 (2^(h-1) < n <= 2^(h) -1)
### 편향 이진 트리
- 높이 h에 대한 최소 개후의 노드 가지면서 한쪽 방향의 자식 노드만 가짐
- 비효율적. 왼쪽 자식만 가진 경우, 오른쪽 자식이 들어갈 공간을 남겨 둬야 해서 메모리 낭비 발생
- 편향 이진 트리가 발생할 경우 깨트려도 괜찮은 상태라면 다른 자료구조로 재구성하는 게 다음 탐색에 좋음
### 리스트를 이용한 이진 트리 표현
- 코드에 구현
- 노드 번호가 i일 때
  - 왼쪽 자식 노드 번호: 2i
  - 오른쪽 자식 노드 번호: 2i + 1
  - 부모 노드 번호: i // 2
- 인덱스 0부터 하면
  - 왼쪽 자식 노드 번호: 2i + 1
  - 오른쪽 자식 노드 번호: 2i + 2
  - 부모 노드 번호: (i - 1) // 2
- 보통 인덱스 0에 none 넣고 1부터 시작함. 그쪽이 계산이 편하기 때문
- 노드 번호 주의깊게 보기. out of range 날 수 있음
- 수업 내용은 루트 레벨을 1로 잡음
  - 헷갈린다..
  - 강의 계속 다시보기
## 이진 트리 순회
- 순회: 트리의 노드들을 체계적으로 방문
- 전위, 중위, 후위 순회
  - 순회 대상을 누구를 먼저 처리하는지의 기준점 차이
- 서브트리를 방문, 루트 출력, 다시 서브트리 방문 반복
### 전위 순회 (Preorder Traversal)
- 루트 노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리
- 그럼 뭔가 visited 이런거 있어야 하나?
### 중위 순회 (Inorder Traversal)
- 왼쪽 서브트리 -> 루트 노드 -> 오른쪽 서브트리
- 루트 방문, 자식 있나 확인, 자식 있으면 이동, 처리 끝나면 루트 방문, 오른쪽 자식 있나 확인, 있으면 이동
### 후위 순회 (Postorder Traversal)
- 왼쪽 끝까지 감 -> 오른쪽 끝까지 감 -> 루트

### 추가 구분
- print -> left -> right : 전위
- left -> print -> right : 중위
- left -> right -> print : 후위

## 트리 순회 구현
- 재귀적으로 구현하는게 가장 직관적
- traversal.py 코드 참고
- 이진 트리 먼저 구현해보고 나중 가서 좀 더 복잡한 트리 구현

### 트리 구현(객체)
- 코드 참고

## 트리의 활용
- 탐색 시 왼쪽 노드에 루트보다 작은 값, 오른쪽 노드에 루트보다 큰 값 저장되어 있으면 찾으려는 값에 따라 범위 좁혀나갈 수 있음
- 편향 상황을 막기 위해 AVL트리같은 걸 사용하기도 함 (오늘 다룰 건 아니고 나중에)

# 그래프
- 아이템들과 이들 사이의 연결 관계 표현
- 선형 자료구조나 트리 자료구조로 표현하기 어려운N:M 관계 표현 가능
- 정점(vertex): 그래프의 구성요소, 하나의 연결점
- 간선(edge): 두 정점 간의 연결선
- 차수(degree): 특정 정점에 연결된 간선의 수
## 유형
- 무방향 그래프(Undirected Graph): 간선에 방향성이 없음
- 방향 그래프(Directed Graph, Digraph): 간선에 방향성이 있음
  - 진입, 진출 차수 구분
- 가중치 그래프(Weighted Graph): 간선에 가중치(비용, 거리 등)가 부여된 그래프
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph): 방향 그래프 중 사이클이 없는 그래프
- 트리(Tree): 사이클이 없는 연결 그래프
- 완전 그래프(Complete Graph): 모든 정점이 서로 연결된 그래프
  - 엣지 수가 최대. 순열 생각하면 됨
- 부분 그래프(Subgraph): 원래 그래프의 일부 정점과 간선으로 구성된 그래프
### 인접 정점
- 인접 정점(Adjacent Vertex): 간선으로 직접 연결된 두 정점
- 두 개의 정점에 간선 존재하면 인접해 있다고 한다
## 그래프 표현
- 정보 저장 방식, 메모리, 성능 고려해서 결정
- 인접 행렬
  - 2차원 배열로 그래프 표현
- 인접 리스트
  - 각 정점에 연결된 정점들의 리스트로 그래프 표현
- 간선 리스트
  - 그래프의 모든 간선을 리스트로 저장
### 인접 행렬
- 2차원 배열 사용
- 두 정점을 연결하는 간선 유무를 행렬로 표현
  - 행 번호와 열 번호: 그래프 정점 번호
  - 두 정점이 인접되어 있으면 1, 아니면 0
- 무향 그래프
  - i번째 행의 합 = i번째 열의 합 = i번째 정점의 차수
- 유향 그래프
  - i번째 행의 합 = i번째 정점의 진출 차수
  - i번째 열의 합 = i번째 정점의 진입 차수 
- 장점
  - 구현이 간단하고 직관적
  - 특정 두 정점 간의 간선 존재 여부를 O(1)에 확인 가능
  - 정적 그래프에 적합
- 단점
  - 메모리 비효율적
  - 간선 수 확인, 인접 정점 나열 연산 느림
  - 정점은 많은데 간선이 적으면 쓸데없이 공간만 차지함
- 적합한 상황
  - 밀집 그래프(정점들이 많이 연결된 그래프)
  - 두 정점 사이 간선이 있는지 빠르게 확인하는 경우
### 인접 리스트
- 각 정점에 대한 인접 정점들 순차적 표현
- 하나의 정점에 대한 인접 정점들 각각 노드로 하느 연결 리스트로 저장
- 장점
  - 메모리 효율적
  - 간선 수 확인, 인접 정점 나열 연산 빠름
- 단점
  - 특정 두 정점 간의 간선 존재 여부 확인 느림
  - 링크드리스트 구현 복잡
- 적합한 상황
  - 희소 그래프(정점들이 적게 연결된 그래프)
  - 인접 정점 자주 탐색하는 경우
  - 그래프 동적으로 변하는 경우
### 간선 리스트
- 두 정점에 대한 간선 그 자체를 객체로 표현, 리스트로 저장
- 간선 표현하는 두 정점의 정보 나타냄(시작, 끝 정점)
- 장점
  - 필요 간선만 저장해 공간 복잡도 낮음
  - 간선 직접 다루는 연산에 효율적
- 단점
  - 특정 두 정점 간의 간선 존재 여부 확인 느림
  - 인접 정점 나열 연산 느림
- 적합한 상황
  - 간선 중심 연산 수행하는 경우
  - 간선 추가/삭제 빈번한 경우
- 간선 리스트는 그리 자주 사용하지 않음

## 참고
- 그래프 그릴 수 있는 for문 정도 오늘은 만들어보기. 내일 dfs bfs 할 때 자세히 다룸
- 교재에 BST나옴. 참고함해보기. 