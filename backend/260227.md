# Django Authentication
# Cookie & Session
## 개요
- 서버로부터 받은 페이지를 둘러볼 때 서버와 서로 연결된 상태가 아님
### HTTP
- HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 규약
- 웹에서 이루어지는 모든 데이터 교환의 기초
### 특징
- 비 연결 지향(Connectionless)
  - 서버는 요청에 대한 응답 후 연결 종료
- 무상태(Stateless)
  - 연결을 끊는 순간 클라이언트-서버 간의 통신이 끝나며 상태 정보 유지되지 않음
### 상태가 없다는 것은?
- 장바구니에 담은 상품 유지 불가
- 로그인 상태 유지 불가
- 사용자 맞춤형 페이지 제공 불가
- -> 상태 유지를 위한 기술 필요
## Cookie
- 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
- 클라이언트 측에서 저장되는 작은 데이터 파일
- 사용자 인증, 추적, 상태 유지 등에 사용되는 데이터 저장 방식
### 사용 예시
- 서버로부터 쿠키를 받고, 같은 서버에 다른 페이지 재 요청시 저장해 둔 쿠키 함께 전송
### 사용 원리
- 브라우저(클라이언트)가 쿠키를 key-value 형태로 저장
- 쿠키를 저장해 두었다가, 동일 서버에 재요청 시 저장된 쿠키 함께 전송
- 쿠키는 두 요청이 동일 브라우저에서 들어왔는지를 판단할 때 주로 사용
  - 사용자의 로그인 상태 유지 가능
  - 상태가 없는(stateless) HTTP 프로토콜에서 상태 정보를 기억시켜 주기 때문
### 장바구니 예시
- 장바구니에 상품 담아 둔 채로 개발자 도구 -> network -> cartView.pang 확인
- 서버는 응답과 함께 Set-Cookie 응답 헤더를 브라우저에 전송
  - 클라이언트에게 쿠키 저장하라고 전달하는 것
- Cookie 데이터 자세히 확인
- Application탭 -> Cookies -> 우클릭, clear, 새로고침 이후 장바구니 빈 것 확인
### 사용 목적
- 세션 관리(Session Management)
  - 로그인, 아이디 자동완성, 공지 하루 안 보기, 팝업 체크, 장바구니 등 정보 관리
- 개인화(Personalization)
  - 사용자 선호 설정, 테마 등의 설정
- 트래킹(Tracking)
  - 사용자 행동 기록 및 분석
## Session
- 서버 측에서 생성, 클라이언트와 서버 간의 상태 유지
- 상태 정보를 저장하는 데이터 저장 방식
- 쿠키에 세션 데이터 저장해 매 요청시마다 세션 데이터 함께 전송
### 작동 원리
1. 클라이언트가 로그인 하면 세션 데이터 생성 후 저장
2. 생성된 session 데이터에 인증 가능한 session id 발급
3. 발급한 session id를 클라이언트에게 응답
4. 클라이언트는 응답 받은 session id를 쿠키에 저장
5. 클라이언트가 다시 동일 서버 접속시 요청과 함께 쿠키(session id가 저장됨)를 서버에 전달
6. 쿠키는 요청 때마다 서버에 함께 전송. 서버에서 쿠키에 저장된 session id 확인해 로그인 상태 확인.
- 서버 측에서는 세션 데이터를 생성 후 저장, 이 데이터에 접근할 수 있는 세션 ID 생성, 이 ID를 클라이언트 측으로 전달, 클라이언트는 쿠키에 세션 ID 저장

## 실습
- 장고 rest framework에서 세션 인증 사용해 로그인 기능 만들기
- 원래는 auth.user사용하고 있었음. 오늘은 accounts라는 앱(장고에서 이름 권장) 만들어서 사용할 것
- models에서 모델 정의 시 models.Model이 아닌 AbstractUser 상속받음.
  - username가 기본적으로 제공됨.
  - password를 많이 신경써야 함. 해싱되어 저장됨. salt값도 같이 저장됨.
  - 아무 필드도 안바꾸고 그냥 상속받은 뒤 pass할것. 혹시 확장될 수 있는 여지 남겨두기
- settings.py에서 AUTH_USER_MODEL = 'accounts.User'로 설정
- 유저:article = 1:N 관계
- 인증 가능한 정보를 토대로 어떤 유저인지 확인할 수 있게 되어야 
- API 사용할때는 세션 방식으로 저장 안함. accounts에 signals라는 애가 있음(혼자서는 만들어야함)
- Token import 받아서 사용. django_rest_framework.authtoken.models에서 Token import
- post_save 시그널을 받으면 reciever로 데코레이트된 함수 실행됨
### DRF
- 장고에서 제공하는 가장 기본적인 인증 방식
- dj-rest-auth : 인증 기능 쉽게 도와주는 패키지, 가장 안정적이었음.
- 장고는 웹 프레임워크라 세션 인증을 제공하긴 하지만 유저가 할 일이 좀 많음
- dj-rest-auth를 사용해 restful하게 로그인 기능 구현하기
- `pip install dj-rest-auth`

## 인증
### 인증(Authentication)
- 수신된 요청을 해당 요청의 사용자 또는 자격 증명과 연결하는 메커니즘
- 누구인지 확인하는 과정
- 권한: 요청에 대한 접근 허용/거부 여부 결정
### 인증과 권한
- 순서상 인증이 먼저 진행, 수신 요청을 해당 요청의 사용자 또는 해당 요청이 서명된 토큰과 같은 자격 증명 자료와 연결
- 그 다음 권한 및 제한 정책은 인증이 완료된 해당 자격 증명을 사용하여 요청 허용 여부 결정
### DRF에서 인증
- 인증은 항상 view 함수 시작 시, 권한 및 제한 확인 발생 전, 다른 코드 진행 허용 전에 실행
- 인증 자체로는 들어오는 요청 허용/거부 불가, **단순히 요청에 사용된 자격 증명만 식별**
### Session 대신 Token 인증을 사용하는 이유
- 세션 기반 인증은 서버에 세션 데이터 저장하는 상태 저장 방식(stateful)
- 서버가 사용자의 상태 유지 필요, 여러 서버를 사용하는 분산 시스템 구축과 서버 간 부하 분산 어려움
- 토큰 기반 인증은 RESTful한 방식으로 클라이언트-서버 간 독립성 유지하며 인증 처리 가능
- -> RESTful 원칙에 더 부합합
## 인증 체계 설정
### 인증 체계 설정 방식 2가지
1. 전역 설정
2. View 함수 별 설정
- 인증 방식 나눌 수도 있음
### 전역 설정
- settings.py에서 REST_FRAMEWORK 설정에 DEFAULT_AUTHENTICATION_CLASSES 항목 추가
- 예시:
```python
    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES': [
            'rest_framework.authentication.SessionAuthentication',
            'rest_framework.authentication.TokenAuthentication',
        ],
    }
``` 
- 이렇게 설정하면 모든 view 함수에서 세션 인증과 토큰 인증이 기본적으로 적용됨
### View 함수 별 설정
- view 함수마다 authentication_classes 데코레이터 사용하여 인증 체계 설정
### TokenAuthentication
- token기반 HTTP 인증 체계
- 기본 데스크톱 및 모바일 클라이어트 같은 클라이언트-서버 설정에 적합
- 서버가 인증된 사용자에게 토큰 발급, 사용자는 매 요청마다 발급받은 토큰 요청과 함께 인증 과정 거침
## Token 인증 설정
1. 인증 클래스 설정
2. INSTALLED_APPS에 'rest_framework.authtoken' 추가
3. Migrate 명령어로 데이터베이스에 토큰 모델 생성
4. 토큰 생성 코드 작성
-> 귀찮으니 라이브러리 사용
### dj-rest-auth
- 회원가입, 인증, 비밀번호 재설정, 사용자 세부 정보 검색, 회원 정보 수정 등 다양한 인증 관련 기능 제공하는 라이브러리
- `pip install dj-rest-auth` 명령어로 설치
- 프로젝트 settings.py 파일의 INSTALLED_APPS 리스트에 'dj_rest_auth' 추가하여 등록
- `pip freeze > requirements.txt` 명령어로 의존성 파일 생성
- urls.py에서 dj-rest-auth의 urls.py를 include하여 인증 관련 URL 패턴 추가
### Registration 기능 추가 설정
1. 패키지 추가 설치(requirements에 등록되어 있어 설치되어있을것임)
  - 현재 버전과 실습 버전은 차이가 있어 warning 뜰 수 있음. 교재 참고해 혼자할때는 버전 다운그레이드 
  - `pip install django-allauth[with-social]`
  - `pip isntall django-allauth==64.0`
2. 추가 app 등록
3. 추가 url 등록
4. migrate
### django-allauth
- Django에서 OAuth 인증을 쉽게 구현할 수 있도록 도와주는 라이브러리
- 의존성이 깊어지고 있다. -> 깃허브 issue 정보 확인해주는 게 좋음
  - 에러 발생하면 한번씩 확인해보기
- ai의존도가 많이 높은데 이슈 한번씩 확인해주기
### middleware
- 요청과 응답 처리 과정 중간에 해주는 작업
- django settings.py에서 MIDDLEWARE 설정에 추가하여 등록

## 실습
- 주석 해제 다 하고 postman에서 실습 진행
- key값 따라 보내면 세션 키를 전송해줌
- username, password1, password2를 accounts/sighup/ 로 post 요청 보내면 회원가입되어 세션 키 전송해줌
- 국내 api 사용해보면 좋음.
### 토큰 받아서 사용하기
- 토큰 없이 그냥 글쓰는 요청 보내면 500 에러 발생.
- anonymous user는 글을 쓸 수 없기 때문. 로그인한 유저만 글을 쓸 수 있도록 설정되어 있기 때문
- headers에 Authorization : Token + (공백한칸)토큰값 넣어서 요청 보내면 글쓰기 가능
- 가본 설정을 어떻게 정의할지도 정할 수 있음
- DEFAULT_PERMISSION_CLASSES를 IsAuthenticated로 설정하면 인증된 사용자만 접근 가능하게 설정할 수 있음. -> 인증된 사용자만 글쓰기 가능하게 설정할 수 있음
  - 이때 인증 안된 사용자 보내면 401 에러 발생
- 전역 설정이 먼저 적용, 함수 설정된 게 있으면 함수 실행될 때 덮어써서 적용됨.
- api_view 받을 때 authentication_classes, permission_classes 같이받아오기
- 그렇게 게시물 작성할때만 인증받게하기
- isAdmin 같은 권한도 설정할 수 있음. -> 관리자만 글쓰기 가능하게 설정할 수 있음
  - 이런 공식문서 잘 읽어보고 사용할것. 어지간한 건 공식문서에 있다.
### 왜 DRF를 배웠을까?
- 백엔드-프론트엔드 분리 경험
  - 기존 장고 템플릿 기반의 서버 렌더링 방식을 벗어나 백엔드-프론트엔드를 명확히 분리하는 패턴 간접적 체험
- 표준화된 API 구축 역량 확보
  - DRF를 통해 RESTful API를 쉽게 만들고 관리하는 방법 학습
  - 이는 다양한 클라이언트와 연동하는 데 필수적
- 프론트엔드 기술과의 연결고리
  - 앞으로 학습할 Javascript 및 Vue는 주로 API를 통해 데이터 받아와 화면 구성
  - DRF로 구축한 일관된 API는 Vue등 프론트엔드 프레임워크와 매끄럽게 호환