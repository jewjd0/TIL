# DOM & Event
## Javasctipt의 역사
### ECMAScript
- Ecma international이 정의하고 있는 표준화된 스크립트 프로그래밍 언어 명세
  - 스크립트 언어가 준수해야 하는 규친, 세부사항
  - 원래 권위있던건 아닌데 어째 국제화가 됨
- 원래는 브라우저마다 다 따로 공부했어야 함. 그걸 바꿔서 표준화한 게 ECMAScript
- 타입스크립트: js기반, 타입을 좀더 엄격하게 봄
- ES6(2015년)이후의 문법을 따를 것.
- 현재 크롬, 파이어폭스, 사파리 등 다양한 브라우저가 있지만 문법 자체는 통합되었다

## JavaScript
### 변수
  - **식별자 작성 규칙**
    - 문자, 달러($), 밑줄(_)로 시작
    - 대소문자 구분
    - 예약어 사용 불가(for, if, function)
    - **camelCase** : 변수, 객체, 함수에 사용
    - **PascalCase** : 클래스, 생성자에 사용
    - **SNAKE_CASE(대문자)** : 상수(constants)에 사용
  - let
    - 블록 스코프(block scope)를 갖는 지역 변수 선언
    - 재할당 가능
    - 재선언 불가능
    - ```javascript
      // let
      let number = 10
      // 재할당 가능
      number = 20
      // 재선언 불가능 
      let number = 20 //오류 발생 지점
      ```
  - const
    - 블록 스코프(block scope)를 갖는 지역 변수 선언
    - 재할당 불가
    - 재선언 불가
    - ES6에서 추가됨
    - ```javascript
      // const
      const secondNumber = 10
      // 재할당 불가능
      secondNumber = 20 //오류 발생
      // 재선언 불가능
      const secondNumber = 30 //오류 발생
      ```
  - const?  let?
    - 기본적으로 const 사용 권장
    - 재할당이 필요하면 그때 let으로 변경해서 사용
  - var
    - 이번 수업에선 사용하지 않음
  - block scope
    - if, for, 함수 등의 중괄호({}) 내부
    - 블록 스코프를 가진 변수는 바깥에서 접근 불가
### 데이터 타입
  - 원시 자료형 (Primitive type)
    - Number, String, Boolean, null, undefined
    - 변수에 값이 직접 저장되는 자료형. 
    - 불변, 값 복사
    - 변수 할당 시 값 복사 = 변수 간 서로 영향 X
    - Number : 정수형/실수형 숫자
      - 무한: Infinity
      - NaN : Not a Number (계산이 불가)
    - String : 텍스트 데이터
      - Template literals : 내장된 표현식 허용하는 문자열 작성 방식.
        - 백틱 사용 `홍길동은 ${변수}세 입니다.`
        - 복잡한 수식 권장X. 메소드 호출 1회 정도만
    - null : 변수의 값이 없음 (넣을 게 없다는 의사표시)
    - undefined : 변수 선언 이후 값이 할당되지 않음. (값이 뭔지 모름. 뭔가 넣어야 하는데 안넣음)
    - null, undefined 두 개로 나뉜 이유는 사실 설계 실수.
      - null은 primitive type인데 object로 나옴. 사용 시 주의할 것
    - Boolean
  - 참조 자료형 (Reference type)
    - Objects (Object, Array, Function)
    - 어떤 주소(객체 주소 등)를 참조.
    - 객체 주소가 저장되는 자료형
    - 가변, 주소 복사
    - 객체 생성 시 객체 메모리 주소를 변수에 할당 = 변수 간 영향 O
    - const로 선언해도 내부 변수 값은 바꿀 수 있다!
  - 연산자
    - 증감 연산자는 for문 말고 안씀
  - 동등 연산자(==)
    - 잘 안쓴다.
    - 암묵적 형변환을 통해 타입을 일치시키고 같은 값인지 비교
    - '0' == 0 //true이다.
    - 0 == [] //true
    - "0" == [] //false
  - 일치 연산자(===)
    - 값, 타입이 모두 일치하면 true
    - 엄격한 비교
    - 특수 경우 제외하고 일치 연산자 사용 권장
  - 논리 연산자
    - &&, ||, !
    - 단축 평가 지원
### 조건문
  - if
  - 삼항 연산자 
    - condition ? expression1 : expression2
    - condition이 true이면 expression1, false면 expression2 실행
    - 조건부 로직 간결하게. 아주 심플한 경우 사용
### 반복문
  - while
    - ```javascript
      while (i < 6) {
      console.log(i)
      i += 1
      }
      ```
  - for
    - ```javascript
      for(let i = 0 ; i < 6 ; i++){
        cosnole.log(i)
      }
      ```
    - 배열을 인덱스 순으로 접근할 때 for문 사용
  - for ...in
    - 객체의 열거 가능한 속성에 대해 반복
    - ```javascript
      const object = {
        a: 'apple',
        b: 'banana'
      }

      for (const property in object) {
        console.log(property)
        console.log(object[property])
      }
      ```
    - 인덱스 취급하면 안됨. 순서 보장 안해준다!
  - for ...of
    - 반복 가능한 객체(배열, 문자열 등)에 대해 반복
    - ```javascript
      const numbers = [0, 1, 2, 3]

      for (const number of numbers) {
        console.log(number) // 0, 1, 2, 3
      }

      const myStr = 'apple'

      for (const str of myStr) {
        console.log(str) // a, p, p, l, e
      }
      ```

## DOM
### JS 실행 환경 종류
  1. HTML script태그
  2. .js 확장자 파일
       - 이 경우 node가 없으므로 script 태그에 src로 경로 알려줘야함
  3. 브라우저 콘솔
### DOM (The Document Object Model)
  - 웹 페이지를 구조화된 객체로 제공하여 프로그래밍 언어가 페이지 구조에 접근할 수 있는 방법 제공
    - 문서 구조, 스타일, 내용 변경 가능하게 함
  - DOM API: 다른 프로그래밍 언어가 웹 페이지에 접근, 조작할 수 있도록 페이지 요소들을 객체 형태로 제공, 그에 따른 메서드 제공
  - 특징
    - 모든 요소, 속성, 텍스트는 하나의객체
    - 모두 document 객체의 하위 객체로 구성
    - 트리 형태 구조
  - DOM tree
    - 브라우저는 HTML 문서를 해석, DOM tree라는 객체 트리로 구조화<br>
    = 객체 간 상속 구조 존재
    - body태그 안의 h1, a 태그<br>
    => body객체를 상속한 h1, a 객체
  - DOM 핵심
    - 문서의 요소를 객체로 제공, 다른 프로그래밍 언어에서 접근하고 조작할 수 있는 방법을 제공하는 API
### document 객체
  - 웹 페이지 객체
  - DOM tree 진입점
  - 페이지 구성하는 모든 객체 요소 포함
  - 예시 : HTML title 변경
    - console에서 document.title = 'hello' 하면 진짜로 바뀐다
### DOM 선택
  - DOM 조작 시 기억해야 할 것 
    - 웹 페이지를 동적으로 만들기 == 웹 페이지를 조작하기
    - 조작 순서:<br>
    1. 조작하고자 하는 요소 선택(탐색)
    2. 선택된 요소의 콘텐츠/속성 조작
### 선택 메서드
  - document.querySelector()
    - 요소 한 개 선택
    - 제공한 선택자와 일치하는 element 한 개 선택
    - 여러 개라면 **첫 번째 객체**, 없다면 **null** 반환
  - document.querySelectorAll()
    - 요소 여러 개 선택
    - 제공한 선택자와 일치하는 여러 element 선택
    - 제공한 CSS selector를 만족하는 NodeList 반환
  - CSS Selector 선택하듯이 사용

## DOM 조작
### 속성 조작
  - 클래스 속성 조작
    - 'classList' property <br>
    요소의 클래스 목록을 DOMTokenList(유사배열) 형태로 반환 <br>
    - element.classList.add()<br>
      지정한 클래스 값 추가<br>
    - element.classList.remove()<br>
      지정한 클래스 값 제거<br>
    - **element.classList.toggle()**<br>
      클래스 존재 시 제거, false 반환<br>
      존재하지 않으면 추가, true 반환<br>
      다크모드 조작 같은 것에 자주 사용<br>
  - 일반 속성 조작
### 일반 속성 조작 메서드
  - Element.getAttribute()
    - 해당 요소에 지정된 겂 반환(조회)
  - Element.setAttribute(name, value)
    - 지정된 요소 속성 값 설정
    - 속성이 이미 있으면 기존 값 갱신
    - 그렇지 않으면 지정된 이름, 값으로 새 속성 추가
  - Element.removeAttribute()
    - 요소에서 지정된 이름 가진 속성 제거
### HTML 콘텐츠 조작

### DOM 요소 조작
  - document.createElement(tagName)
    - 작성한 tagname의 HTML 요소 생성하여 반환
  - Node.appendChild()
    - 한 Node를 특정 부모 Node의 자식 NodeList중 마지막 자식으로 삽입
  - Node.removeChild()
    - DOM에서 자식 노드 제거
    - 제거된 노드 반환
### document.querySelector()
  - 이거 하나만 기억해두고 나머지는 필요할 때만 찾아도 됨

## 함수
 - 참조 자료형에 속하며 모든 함수는 Function object
### 함수 구조
  ```javascript
  function name([param[, param[..., param]]]){
    statements
    return value
  }
  ```
  - 보편적으로 사용하는 함수 형태. function 키워드만 기억해둘 것
  - return 없으면  undefined 반환
### 함수 정의
  - 선언식
  - ```javascript
    function funcName () {
      statement
    }
    ```
  - 표현식
  - ```javascript
    const sub =  funcName (num1, num2) {
      statement
    }
    ```
    - 함수 이름이 없는 익명 함수 사용 불가
    - 선언식과 달리 표현식으로 정의한 함수는 호이스팅 되지 않으므로 함수를 정의하기 전에 먼저 사용 불가
      - 호이스팅? 함수 사용 위치가 선언 위치보다 위면 선언 위치 찾아서 끌어올려서 사용
      - 메소드에서 쓸때나 선언식을 쓸수도 아닐수도
    - 표현식 사옹 권장
### 매개변수 
  - 나머지 매개변수
    - 임의의 수의 인자 배열로 허용하여 가변 인자 나타냄
    - 하나만 작성 가능
    - 매개변수 마지막에 위치
  - ***매개변수와 인자 개수가 불일치할 때***
    - 매개변수 개수 > 인자 개수
      - 누락된 인자 undefined로 할당
    - 매개변수 개수<인자 개수
      - 초과 입력한 인자는 사용 x
    - 타입 억제하고싶으면 타입스크립트를 가라
### Spread syntax
  - '...' : 전개 구문
    - 배열이나 문자열 같이 반복 가능한 구문 확장/전개
### 화살표 함수
  - 짧은 함수 작성
  - ```javascript
      const arrow = function(name) {
      return `hello,${name}`
      } 
    ```
  - ```javascript
      const arrow = name => `hello,${name}`
    ```
  - 콜백 함수같은거에서 사용한다는데 내일 진도나감


## 이벤트
  - 예시(일상)
    - 컴퓨터 키보드 눌러 텍스트 입력, 전화 왔음 알림, 버튼 눌러 통화 시작
  - 예시(웹)
    - 화면 스크롤, 버튼 클릭 시 팝업 창 출력, 커서 위치에 따라 드래그&드롭
    - 웹에서의 모든 동작은 이벤트로 감지 가능<br>
      (키다운, 프레스홀더, 키업 등등 종류는 MDN가서 찾기)
### event handler
  - .addEventListener()
    - 이벤트가 발생했을 때 이벤트 추가 <br>
      => 특정 이벤트를 돔 요소가 수신할 때마다 콜백 함수 호출
    - EventTarget.addEventListener(type, handler)
    - 대상에 특정 이벤트 발생 시 지정한 이벤트 받아 할 일 등록
    - handler에 함수 직접 정의도 가능
### 버블링
  - 한 요소에 이벤트 발생 시 이 요소에 할당된 핸들러 동작, 이어서 부모 요소의 핸들러 동작
  - 최상단 조상 요소(document) 만날 때까지 이 과정 반복, 요소 각각에 할당된 핸들러 동작
  - ```HTML
    <form>
      <div>
        <p>요소</p>
      </div>
    </form>
    ```
      - 해당 구조에서 모두 핸들러가 있으면 p를 클릭했을 때 div, form의 핸들러도 작동한다
  - 부모 요소를 거슬러 올라가며 발생하는 게 거품같대고 버블링이라고 부른다.
  - currentTarget & target 속성
    - currentTarget
      - 현재 요소
      - this
      - 이벤트 핸들러가 연결된 요소만 참조
    - target
      - 이벤트 발생한 가장 안쪽의 요소 
      - 실제 이벤트 시작 요소
      - 버블링 되어도 변하지 않음
    - 버튼들을 세트로 html로 묶어 두고 이벤트핸들러를 상위 객체에, 조건문 달아서 버튼 구분하면 핸들러를 여러개 둘 필요가 없다.
  - ***.preventDefault()***
    - 해당 이벤트에 대한 기본 동작을 실행하지 않도록 지정
    - html이 지정해 둔 기본 동작 실행 방지
    - copy이벤트 동작 취소 -> 콘텐츠 복사 방지
    - form 제출 시 전송, 새로고침 동작 취소
      - form 요소의 submit동작 취소
    - 매우매우 중요!
    - stopPropagation이란 게 있는데 그거랑은 다름.